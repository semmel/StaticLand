{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"@visisoft/staticland v0.1.24 Operations on Algebraic Data Types (ADT) (Either, Maybe, Promise, CancelableComputation) realised with free static functions . The static functions do not expect custom-made ADT classes but work on the native JavaScript types as Array , Promise and Function . Fairness demands to confess that Function carries some data in closed over variables. Using simple native types means that Conversion between the types is easy, but @visisoft/staticland practically gives up on type inspection and leaves that to the calling code. This is in line with the characteristics of JavaScript. of map chain Consumption Maybe x => [x] Array.prototype.map Array.prototype.flatMap xs => xs[0] Either x => [,x] Array.prototype.map Array.prototype.flatMap xs => xs[1] CancelableComputation cc = (resolve, reject) => () => () new Promise(cc) Promise Promise.resolve Promise.then Promise.then Promise.then IO x => x compose run(compose) call In a way @visisoft/staticland provides functions which operate on and access types you operate with anyway. Homepage and Documentation Hello @visisoft/staticland Installation npm install @visisoft/staticland Hello Earth Greeting with a 0.5 sec 2-way delay. Usage in an ES module import {map as map_p, mapRej as mapRej_p, chain as chain_p} from '@visisoft/staticland/promise'; import {fromThrowable} from '@visisoft/staticland/either'; import {fromNilable, getOrElse} from '@visisoft/staticland/maybe'; import {curry, pipe} from 'ramda'; // or pipe from 'crocks' or any other composition function const // :: String -> {k: String} -> Maybe String getProperty = R.curry((property, object) => fromNilable(object[property])), // :: a -> Promise any a delay = x => new Promise(resolve => setTimeout(resolve, 500, x)), // :: any -> Either Error String safeGreet = fromThrowable(x => \"Hello \" + x.toString() + \"!\"), // :: any -> Promise (Maybe String) String getAnswer = R.pipe( delay, // Promise any any map_p(safeGreet), // Promise any (Either Error String) chain_p(delay), // Promise any (Either Error String) chain_p(eitherToPromise), // Promise (any|Error) String mapRej_p(getProperty('message')) // Promise (Maybe String) String ); getAnswer(\"Earth\") .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Hello Earth!\" getAnswer(null) .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Cannot read property 'toString' of null\" Usage in a CommonJS module const {chain: chain_p} = require('@visisoft/staticland/promise'), delay = t => x => new Promise(resolve => setTimeout(resolve, t, x)); chain(delay(500), Promise.resolve(\"foo\")).then(console.log); Objective Support programming in functional pipelines by exposing a familiar set of operations on asynchronous, optional and faulty data. Design Most functions comply with Static-Land `s algebraic laws. Where this is not possible (e.g. nesting of resolved Promises) a few reasonable paradigms have to be followed when using this library. At the expense of complete algebraic lawfulness the data wrapping remains transparent and light-weight. The functions are designed to support the usual functional programming style in JavaScript as it is the design philosophy for many libraries for example Ramda's : Emphasise a purer functional style. Immutability and side-effect free functions help to write simple yet elegant code. Automatic currying. This allows you to easily build up new functions from old ones simply by not supplying the final parameters. Parameter order supports convenient currying. The data to be operated on is generally supplied last, so that it's easy to create functional pipelines by composing functions . Related Fantasy-Land Libraries Ramda-Fantasy is very well documented, but sadly no longer maintained. Crocks is an exemplary implementation of common data types. Dependencies As FP utility library Ramda is used. The patch fork semmel-ramda will be replaced with Ramda when it gets published as proper dual-mode or hybrid module. closed over A closure is the combination of a function and the lexical environment within which that function was declared.","title":"Welcome"},{"location":"#visisoftstaticland-v0124","text":"Operations on Algebraic Data Types (ADT) (Either, Maybe, Promise, CancelableComputation) realised with free static functions . The static functions do not expect custom-made ADT classes but work on the native JavaScript types as Array , Promise and Function . Fairness demands to confess that Function carries some data in closed over variables. Using simple native types means that Conversion between the types is easy, but @visisoft/staticland practically gives up on type inspection and leaves that to the calling code. This is in line with the characteristics of JavaScript. of map chain Consumption Maybe x => [x] Array.prototype.map Array.prototype.flatMap xs => xs[0] Either x => [,x] Array.prototype.map Array.prototype.flatMap xs => xs[1] CancelableComputation cc = (resolve, reject) => () => () new Promise(cc) Promise Promise.resolve Promise.then Promise.then Promise.then IO x => x compose run(compose) call In a way @visisoft/staticland provides functions which operate on and access types you operate with anyway.","title":"@visisoft/staticland v0.1.24"},{"location":"#homepage-and-documentation","text":"","title":"Homepage and Documentation"},{"location":"#hello-visisoftstaticland","text":"","title":"Hello @visisoft/staticland"},{"location":"#installation","text":"npm install @visisoft/staticland","title":"Installation"},{"location":"#hello-earth","text":"Greeting with a 0.5 sec 2-way delay.","title":"Hello Earth"},{"location":"#usage-in-an-es-module","text":"import {map as map_p, mapRej as mapRej_p, chain as chain_p} from '@visisoft/staticland/promise'; import {fromThrowable} from '@visisoft/staticland/either'; import {fromNilable, getOrElse} from '@visisoft/staticland/maybe'; import {curry, pipe} from 'ramda'; // or pipe from 'crocks' or any other composition function const // :: String -> {k: String} -> Maybe String getProperty = R.curry((property, object) => fromNilable(object[property])), // :: a -> Promise any a delay = x => new Promise(resolve => setTimeout(resolve, 500, x)), // :: any -> Either Error String safeGreet = fromThrowable(x => \"Hello \" + x.toString() + \"!\"), // :: any -> Promise (Maybe String) String getAnswer = R.pipe( delay, // Promise any any map_p(safeGreet), // Promise any (Either Error String) chain_p(delay), // Promise any (Either Error String) chain_p(eitherToPromise), // Promise (any|Error) String mapRej_p(getProperty('message')) // Promise (Maybe String) String ); getAnswer(\"Earth\") .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Hello Earth!\" getAnswer(null) .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Cannot read property 'toString' of null\"","title":"Usage in an ES module"},{"location":"#usage-in-a-commonjs-module","text":"const {chain: chain_p} = require('@visisoft/staticland/promise'), delay = t => x => new Promise(resolve => setTimeout(resolve, t, x)); chain(delay(500), Promise.resolve(\"foo\")).then(console.log);","title":"Usage in a CommonJS module"},{"location":"#objective","text":"Support programming in functional pipelines by exposing a familiar set of operations on asynchronous, optional and faulty data.","title":"Objective"},{"location":"#design","text":"Most functions comply with Static-Land `s algebraic laws. Where this is not possible (e.g. nesting of resolved Promises) a few reasonable paradigms have to be followed when using this library. At the expense of complete algebraic lawfulness the data wrapping remains transparent and light-weight. The functions are designed to support the usual functional programming style in JavaScript as it is the design philosophy for many libraries for example Ramda's : Emphasise a purer functional style. Immutability and side-effect free functions help to write simple yet elegant code. Automatic currying. This allows you to easily build up new functions from old ones simply by not supplying the final parameters. Parameter order supports convenient currying. The data to be operated on is generally supplied last, so that it's easy to create functional pipelines by composing functions .","title":"Design"},{"location":"#related-fantasy-land-libraries","text":"Ramda-Fantasy is very well documented, but sadly no longer maintained. Crocks is an exemplary implementation of common data types.","title":"Related Fantasy-Land Libraries"},{"location":"#dependencies","text":"As FP utility library Ramda is used. The patch fork semmel-ramda will be replaced with Ramda when it gets published as proper dual-mode or hybrid module.","title":"Dependencies"},{"location":"#closed-over","text":"A closure is the combination of a function and the lexical environment within which that function was declared.","title":"closed over"},{"location":"cancelable-api/","text":"Cancelable Computation Signature CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) Leaving the failure type to be implicitly an Error the signature can be shortened: CancelableComputation a :: ((a -> void), (* -> void)) -> (() -> void) Generator Functions of(value) :: a -> Cancelable () a reject(e) :: e => Cancelable e () later(dt, value) :: Number -> a -> Cancelable () a laterReject(dt, e) :: Number -> e -> Cancelable e () fetchResponse({url, fetchSpec}) :: {url: (String|URL), init: {}} -> Cancelable Error Response This example fetches the number of libraries hosted at cdnjs.com . The result is a Cancelable of a Maybe of a Number. The - failure continuation of the cancelable contains network errors and errors in the JSON format of the response, - nothing path of the maybe is taken in case the combined network and parse duration exceeded the timeout , - the just path of the Maybe in the success continuation of the Cancelable contains the result . import {ap, pair, pipe} from 'ramda'; import {chain as chain_c, later, map as map_c, fetchResponse} from '@visisoft/staticland/cancelable'; import { eitherToCancelable, keyPromiseToPromiseCollection, promiseToCancelable } from '@visisoft/staticland/transformations'; import { chain as chain_e, right, left } from '@visisoft/staticland/either'; import {nothing, just, maybe } from '@visisoft/staticland/maybe'; const // :: Pair Response {k:v} => Either {k:v} checkFetchResponseWithPayload = ([response, payload]) => response.ok ? right(payload) : left({ message: response.statusText, code: response.status, payload }), // :: {k:v} -> Either Number checkStatsResult = payload => typeof payload.libraries === \"number\" ? right(payload.libaries) : left({ message: \"Unexpected API response\", payload }), // :: Cancelable Maybe Number numberOfCDNJSLibraries = pipe( () => fetchResponse({url: \"https://api.cdnjs.com/stats\", init: { mode: \"cors\" }}), // :: Cancelable Response map_c(ap(pair, response => response.json())), // :: Cancelable Pair (Response) (Promise {k:v}) map_c(keyPromiseToPromiseCollection(1)), // :: Cancelable Promise Pair (Response) ({k:v}) chain_c(promiseToCancelable), // :: Cancelable Pair (Response) ({k:v}) map_c(checkFetchResponseWithPayload), // :: Cancelable Either {k:v} map_c(chain_e(checkStatsResult)), // :: Cancelable Either Number chain_c(eitherToCancelable), // :: Cancelable Number map_c(just), // :: Cancelable Maybe Number race(later(1000, nothing())), // :: Cancelable Maybe Number )(); new Promise(numberOfCDNJSLibraries) // running .then( // consuming maybeCount => { console.log(maybe( () => \"Info: API request did not complete in time.\", n => `Result: CDNJS hosts ${n} libraries.`, maybeCount )); }, error => { console.log(`Error: fetching CNDJSAPI: \"${error.message}\".\\nData received:\"${JSON.stringify(error.payload)}\"`); } ); Transformation map(f, cancelable) :: (a \u2192 b) \u2192 Cancelable a \u2192 Cancelable \u2192 b chain(f, cancelable) :: (a \u2192 Cancelable b) \u2192 Cancelable a \u2192 Cancelable \u2192 b Combinations ap(cancelableFunc, cancelable) :: Cancelable (a \u2192 b) \u2192 Cancelable a \u2192 Cancelable b Parallel running version: It runs both Cancelable arguments in parallel. Note that when implemented simply ap(mf, ma) = chain(f => map(f, ma), mf) will not run the Cancelable Computations in parallel . liftA2(f, ccA , ccB) :: (a \u2192 b \u2192 c) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c Equivalent to (f, pa, pb) => Promise.all([pa, pb]).then(([a, b]) => f(a, b)) . f must be curried. Note that when implemented by sequential running ap , liftA2(f, ma, mb) = ap(map(f, ma), mb) will not run the Cancelable Computations in parallel . race(cancelableA, cancelableB) :: Cancelable a \u2192 Cancelable a \u2192 Cancelable a Like Promise.race shortcuts (i.e. aborts the other) when any input value is settled with success or failure. Utility share(cancelable) :: Cancelable e a \u2192 Cancelable e a","title":"Cancelable"},{"location":"cancelable-api/#cancelable-computation","text":"","title":"Cancelable Computation"},{"location":"cancelable-api/#signature","text":"CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) Leaving the failure type to be implicitly an Error the signature can be shortened: CancelableComputation a :: ((a -> void), (* -> void)) -> (() -> void)","title":"Signature"},{"location":"cancelable-api/#generator-functions","text":"","title":"Generator Functions"},{"location":"cancelable-api/#ofvalue","text":":: a -> Cancelable () a","title":"of(value)"},{"location":"cancelable-api/#rejecte","text":":: e => Cancelable e ()","title":"reject(e)"},{"location":"cancelable-api/#laterdt-value","text":":: Number -> a -> Cancelable () a","title":"later(dt, value)"},{"location":"cancelable-api/#laterrejectdt-e","text":":: Number -> e -> Cancelable e ()","title":"laterReject(dt, e)"},{"location":"cancelable-api/#fetchresponseurl-fetchspec","text":":: {url: (String|URL), init: {}} -> Cancelable Error Response This example fetches the number of libraries hosted at cdnjs.com . The result is a Cancelable of a Maybe of a Number. The - failure continuation of the cancelable contains network errors and errors in the JSON format of the response, - nothing path of the maybe is taken in case the combined network and parse duration exceeded the timeout , - the just path of the Maybe in the success continuation of the Cancelable contains the result . import {ap, pair, pipe} from 'ramda'; import {chain as chain_c, later, map as map_c, fetchResponse} from '@visisoft/staticland/cancelable'; import { eitherToCancelable, keyPromiseToPromiseCollection, promiseToCancelable } from '@visisoft/staticland/transformations'; import { chain as chain_e, right, left } from '@visisoft/staticland/either'; import {nothing, just, maybe } from '@visisoft/staticland/maybe'; const // :: Pair Response {k:v} => Either {k:v} checkFetchResponseWithPayload = ([response, payload]) => response.ok ? right(payload) : left({ message: response.statusText, code: response.status, payload }), // :: {k:v} -> Either Number checkStatsResult = payload => typeof payload.libraries === \"number\" ? right(payload.libaries) : left({ message: \"Unexpected API response\", payload }), // :: Cancelable Maybe Number numberOfCDNJSLibraries = pipe( () => fetchResponse({url: \"https://api.cdnjs.com/stats\", init: { mode: \"cors\" }}), // :: Cancelable Response map_c(ap(pair, response => response.json())), // :: Cancelable Pair (Response) (Promise {k:v}) map_c(keyPromiseToPromiseCollection(1)), // :: Cancelable Promise Pair (Response) ({k:v}) chain_c(promiseToCancelable), // :: Cancelable Pair (Response) ({k:v}) map_c(checkFetchResponseWithPayload), // :: Cancelable Either {k:v} map_c(chain_e(checkStatsResult)), // :: Cancelable Either Number chain_c(eitherToCancelable), // :: Cancelable Number map_c(just), // :: Cancelable Maybe Number race(later(1000, nothing())), // :: Cancelable Maybe Number )(); new Promise(numberOfCDNJSLibraries) // running .then( // consuming maybeCount => { console.log(maybe( () => \"Info: API request did not complete in time.\", n => `Result: CDNJS hosts ${n} libraries.`, maybeCount )); }, error => { console.log(`Error: fetching CNDJSAPI: \"${error.message}\".\\nData received:\"${JSON.stringify(error.payload)}\"`); } );","title":"fetchResponse({url, fetchSpec})"},{"location":"cancelable-api/#transformation","text":"","title":"Transformation"},{"location":"cancelable-api/#mapf-cancelable","text":":: (a \u2192 b) \u2192 Cancelable a \u2192 Cancelable \u2192 b","title":"map(f, cancelable)"},{"location":"cancelable-api/#chainf-cancelable","text":":: (a \u2192 Cancelable b) \u2192 Cancelable a \u2192 Cancelable \u2192 b","title":"chain(f, cancelable)"},{"location":"cancelable-api/#combinations","text":"","title":"Combinations"},{"location":"cancelable-api/#apcancelablefunc-cancelable","text":":: Cancelable (a \u2192 b) \u2192 Cancelable a \u2192 Cancelable b Parallel running version: It runs both Cancelable arguments in parallel. Note that when implemented simply ap(mf, ma) = chain(f => map(f, ma), mf) will not run the Cancelable Computations in parallel .","title":"ap(cancelableFunc, cancelable)"},{"location":"cancelable-api/#lifta2f-cca-ccb","text":":: (a \u2192 b \u2192 c) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c Equivalent to (f, pa, pb) => Promise.all([pa, pb]).then(([a, b]) => f(a, b)) . f must be curried. Note that when implemented by sequential running ap , liftA2(f, ma, mb) = ap(map(f, ma), mb) will not run the Cancelable Computations in parallel .","title":"liftA2(f, ccA , ccB)"},{"location":"cancelable-api/#racecancelablea-cancelableb","text":":: Cancelable a \u2192 Cancelable a \u2192 Cancelable a Like Promise.race shortcuts (i.e. aborts the other) when any input value is settled with success or failure.","title":"race(cancelableA, cancelableB)"},{"location":"cancelable-api/#utility","text":"","title":"Utility"},{"location":"cancelable-api/#sharecancelable","text":":: Cancelable e a \u2192 Cancelable e a","title":"share(cancelable)"},{"location":"cancelable/","text":"Cancelable Cancelable Computation A Cancelable Computation is a function which performs a cancelable asynchronous computation. CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) In general Cancelable Computations serves the same purpose as a Promises. Contrary to Promises, Cancelable Computations are - lazily executed, - have no internal mutating state - thus are referentially transparent, and - cancellation is not propagated to the consumer. Executing Work The computation is started when the Cancelable Computation function is called - laziness . // Pseudocode let cancelableWork = (res, rej) => { beginSomeLongWork() whenLongWorkDone with result invoke res(result) whenLongWorkFailed with error invoke rej(error) return () => { // abort the work }; }; Consuming Outcome The result or failing of the computation (aka settlement) is communicated via the two callback arguments (\"continuations\") in the same way as the computation function in a Promise constructor . Differently however, the settlement of the computation should not be communicated synchronously - enforced asynchronicity let ccFoo = (res, rej) => { res(\"foo\"); // BAD CODE! Do not invoke the callbacks synchronously! return () => undefined; }; let ccBar = (res, rej) => { const timer = setTimeout(res, 0, \"bar\"); // Always invoke the callbacks asynchronously! return () => { clearTimeout(timer); }; }; Such computation functions are the standard pattern in other libraries to create asynchronous tasks, e.g. creating Fluture Futures or Async in Crocks . Because those other libraries however provide their (lazy) replacement for native Promises, the order of arguments of their computation function differs from that of the Promise constructor in that the rejection continuation comes before the success continuation. By providing the Cancelable Computation in the Promise constructor new Promise(cancelableComputation) it becomes trivial to transform a Cancelable Computation into a Promise. Cancellation The Cancelable Computation Function returns a function to abort/ cancel the computation. A Cancelable Computation can be aborted by calling the abort function which is returned when the execution of the Cancelable Computation is started by invoking it with two callbacks. let abort = cancelableComputation(onSuccess, onFailure); abort(); // Abort immediately. onSuccess and onFailure are never called When a Cancelable Computation aborts, the implementation must assert that neither the success, nor the failure callback are called. This is another difference to many cancelable computations represented by Promises. For example, aborting a fetch computation is known to reject the resulting promise with AbortError . Thus, a Cancelable fetch Computation should guarantee that the AbortError rejection does not reach the onFailure callback. Generators of Cancelable Computations The parameters of the asynchronous computation are given to a Cancelable Computation Generator Function which returns a Cancelable Computation configured to that parameters. This way the configuration of the computation is separated from its execution ( laziness ). The typical example in many similar libraries is that of a timer: // laterResolve :: (Number, t) -> CancelableComputation * t const laterResolve = (dt, value) => resolve => { const timer = setTimeout(resolve, dt, value); return () => { clearTimeout(timer); }; }; Rationale No Synchronicity The reason that a Cancelable Computation cannot synchronously invoke the callbacks with the outcome of the computation, is that otherwise certain combinators were not possible to implement. E.g. mutual cancellation of two simultaneously running computations in race would be much harder to implement. Cancellation Discontinues The two continuation callbacks are to collect the result of the successful computation and any computational error or exceptional path of execution. Aborting/Cancelling the computation by the consumer is not considered to be any of those two purposes. Since the calling code is (obviously) aware of the cancellation it can perform steps to publish that cancellation. The current cancellation behaviour could be extended be supporting asynchronous cancellation - i.e. the cancel function returning a Promise instead of void. However, cancelling the cancellation itself seems to be much of an overkill. Copying/Sharing A benefit of Native Promises is that they can be freely copied and shared in a program. Being eager they rather represent the eventual outcome of a computation than the computation itself. Thus copying makes much sense. However, the internal state of a Promise is time-dependent and thus opaque, i.e. not referentially transparent to the calling code. Depending on when probed by the surrounding code, Promises behave differently; E.g. a Promise.race will take a different route when one of its inputs is already settled. Being just referentially transparent functions, such opaque Promise behaviour is not possible with copies of Cancelable Computations. Everytime the same Cancelable get consumed the asynchronous computation is started anew, and the outcome and temporal behaviour will always be the same. Nevertheless, sharing/multicasting asynchronous computations being valuable, there are at least two ways making Cancelables shareable while maintaining the asynchronous character: - convert to Promise new Promise(cancelableComputation) but thereby loosing cancelability, or - caching/making them stateful with share share picks up many disadvantages of Promise but keeps the benefit of being able to get cancelled when all consumers decide to to so. let ccs = share(later(10, \"X\")); ccs(console.log, console.log); // ~> \"X\" (logged after 10) // \u2026 ccs(console.log, console.log); // ~> \"X\" (logged already on next tick!) Cancelling a shared Cancelable Computation merely means unsubscribing the continuation callbacks. It should be done when the code has lost interest in the outcome of the computation. The shared computation will continue to run if there are still any subscribers which have not cancelled. Otherwise, the internal state is reset, so that the computation will be recommenced on the next call. This way the internal state might toggle between \"initial\" and \"pending\" several times. Once allowed completing, the Shared Cancelable will simply yield the internally stored outcome to the caller.","title":"About Cancelables"},{"location":"cancelable/#cancelable","text":"","title":"Cancelable"},{"location":"cancelable/#cancelable-computation","text":"A Cancelable Computation is a function which performs a cancelable asynchronous computation. CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) In general Cancelable Computations serves the same purpose as a Promises. Contrary to Promises, Cancelable Computations are - lazily executed, - have no internal mutating state - thus are referentially transparent, and - cancellation is not propagated to the consumer.","title":"Cancelable Computation"},{"location":"cancelable/#executing-work","text":"The computation is started when the Cancelable Computation function is called - laziness . // Pseudocode let cancelableWork = (res, rej) => { beginSomeLongWork() whenLongWorkDone with result invoke res(result) whenLongWorkFailed with error invoke rej(error) return () => { // abort the work }; };","title":"Executing Work"},{"location":"cancelable/#consuming-outcome","text":"The result or failing of the computation (aka settlement) is communicated via the two callback arguments (\"continuations\") in the same way as the computation function in a Promise constructor . Differently however, the settlement of the computation should not be communicated synchronously - enforced asynchronicity let ccFoo = (res, rej) => { res(\"foo\"); // BAD CODE! Do not invoke the callbacks synchronously! return () => undefined; }; let ccBar = (res, rej) => { const timer = setTimeout(res, 0, \"bar\"); // Always invoke the callbacks asynchronously! return () => { clearTimeout(timer); }; }; Such computation functions are the standard pattern in other libraries to create asynchronous tasks, e.g. creating Fluture Futures or Async in Crocks . Because those other libraries however provide their (lazy) replacement for native Promises, the order of arguments of their computation function differs from that of the Promise constructor in that the rejection continuation comes before the success continuation. By providing the Cancelable Computation in the Promise constructor new Promise(cancelableComputation) it becomes trivial to transform a Cancelable Computation into a Promise.","title":"Consuming Outcome"},{"location":"cancelable/#cancellation","text":"The Cancelable Computation Function returns a function to abort/ cancel the computation. A Cancelable Computation can be aborted by calling the abort function which is returned when the execution of the Cancelable Computation is started by invoking it with two callbacks. let abort = cancelableComputation(onSuccess, onFailure); abort(); // Abort immediately. onSuccess and onFailure are never called When a Cancelable Computation aborts, the implementation must assert that neither the success, nor the failure callback are called. This is another difference to many cancelable computations represented by Promises. For example, aborting a fetch computation is known to reject the resulting promise with AbortError . Thus, a Cancelable fetch Computation should guarantee that the AbortError rejection does not reach the onFailure callback.","title":"Cancellation"},{"location":"cancelable/#generators-of-cancelable-computations","text":"The parameters of the asynchronous computation are given to a Cancelable Computation Generator Function which returns a Cancelable Computation configured to that parameters. This way the configuration of the computation is separated from its execution ( laziness ). The typical example in many similar libraries is that of a timer: // laterResolve :: (Number, t) -> CancelableComputation * t const laterResolve = (dt, value) => resolve => { const timer = setTimeout(resolve, dt, value); return () => { clearTimeout(timer); }; };","title":"Generators of Cancelable Computations"},{"location":"cancelable/#rationale","text":"","title":"Rationale"},{"location":"cancelable/#no-synchronicity","text":"The reason that a Cancelable Computation cannot synchronously invoke the callbacks with the outcome of the computation, is that otherwise certain combinators were not possible to implement. E.g. mutual cancellation of two simultaneously running computations in race would be much harder to implement.","title":"No Synchronicity"},{"location":"cancelable/#cancellation-discontinues","text":"The two continuation callbacks are to collect the result of the successful computation and any computational error or exceptional path of execution. Aborting/Cancelling the computation by the consumer is not considered to be any of those two purposes. Since the calling code is (obviously) aware of the cancellation it can perform steps to publish that cancellation. The current cancellation behaviour could be extended be supporting asynchronous cancellation - i.e. the cancel function returning a Promise instead of void. However, cancelling the cancellation itself seems to be much of an overkill.","title":"Cancellation Discontinues"},{"location":"cancelable/#copyingsharing","text":"A benefit of Native Promises is that they can be freely copied and shared in a program. Being eager they rather represent the eventual outcome of a computation than the computation itself. Thus copying makes much sense. However, the internal state of a Promise is time-dependent and thus opaque, i.e. not referentially transparent to the calling code. Depending on when probed by the surrounding code, Promises behave differently; E.g. a Promise.race will take a different route when one of its inputs is already settled. Being just referentially transparent functions, such opaque Promise behaviour is not possible with copies of Cancelable Computations. Everytime the same Cancelable get consumed the asynchronous computation is started anew, and the outcome and temporal behaviour will always be the same. Nevertheless, sharing/multicasting asynchronous computations being valuable, there are at least two ways making Cancelables shareable while maintaining the asynchronous character: - convert to Promise new Promise(cancelableComputation) but thereby loosing cancelability, or - caching/making them stateful with share share picks up many disadvantages of Promise but keeps the benefit of being able to get cancelled when all consumers decide to to so. let ccs = share(later(10, \"X\")); ccs(console.log, console.log); // ~> \"X\" (logged after 10) // \u2026 ccs(console.log, console.log); // ~> \"X\" (logged already on next tick!) Cancelling a shared Cancelable Computation merely means unsubscribing the continuation callbacks. It should be done when the code has lost interest in the outcome of the computation. The shared computation will continue to run if there are still any subscribers which have not cancelled. Otherwise, the internal state is reset, so that the computation will be recommenced on the next call. This way the internal state might toggle between \"initial\" and \"pending\" several times. Once allowed completing, the Shared Cancelable will simply yield the internally stored outcome to the caller.","title":"Copying/Sharing"},{"location":"changelog/","text":"Changelog v0.1.24 0.1.24 find_l 0.1.23 bi_tap 0.1.22 updated rollup plugin 0.1.21 added sequence and traverse for Arrays (\"Lists\") added sequence and traverse for Maybe 0.1.20 added maybeOfCancelableToCancelableOfMaybe moved to JSON license generate HTML doc and publish on GitHub pages 0.1.19 added maybeOfBaconObservableToBaconObservableOfMaybe 0.1.16 Begun API for CancelableComputation incl. natural transformations to and from Bacon and Most streams 0.1.15 fix: Either no longer based on a unique Symbol but rather on a unique string. This should make Either compatible with a differently loaded staticland library. 0.1.11 more submodules for Node.js consumption 0.1.4 Adds transformation maybeOfPromiseToPromiseOfMaybe 0.1.2 Added transformations 0.1.1 Added Either type Added transformations fo Either and Maybe to Promise","title":"Changelog"},{"location":"changelog/#changelog-v0124","text":"","title":"Changelog v0.1.24"},{"location":"changelog/#0124","text":"find_l","title":"0.1.24"},{"location":"changelog/#0123","text":"bi_tap","title":"0.1.23"},{"location":"changelog/#0122","text":"updated rollup plugin","title":"0.1.22"},{"location":"changelog/#0121","text":"added sequence and traverse for Arrays (\"Lists\") added sequence and traverse for Maybe","title":"0.1.21"},{"location":"changelog/#0120","text":"added maybeOfCancelableToCancelableOfMaybe moved to JSON license generate HTML doc and publish on GitHub pages","title":"0.1.20"},{"location":"changelog/#0119","text":"added maybeOfBaconObservableToBaconObservableOfMaybe","title":"0.1.19"},{"location":"changelog/#0116","text":"Begun API for CancelableComputation incl. natural transformations to and from Bacon and Most streams","title":"0.1.16"},{"location":"changelog/#0115","text":"fix: Either no longer based on a unique Symbol but rather on a unique string. This should make Either compatible with a differently loaded staticland library.","title":"0.1.15"},{"location":"changelog/#0111","text":"more submodules for Node.js consumption","title":"0.1.11"},{"location":"changelog/#014","text":"Adds transformation maybeOfPromiseToPromiseOfMaybe","title":"0.1.4"},{"location":"changelog/#012","text":"Added transformations","title":"0.1.2"},{"location":"changelog/#011","text":"Added Either type Added transformations fo Either and Maybe to Promise","title":"0.1.1"},{"location":"io/","text":"IO import {tap, o, pipe} from 'ramda'; var beautifyCpuOut = map(t => `${(t / 1.0e+6).toExponential()} sec`), cpu = of(process.cpuUsage), getDeltaCpu = previous => of(() => process.cpuUsage(previous)); pipe( () => cpu, map(tap(o(console.log, beautifyCpuOut))), chain(cpuOut => getDeltaCpu(cpuOut)), map(beautifyCpuOut), run )(); // -> { user: '4.923326e+0 sec', system: '1.297826e+0 sec' } // -> { user: '2.34e-4 sec', system: '2.1e-5 sec' }","title":"Io"},{"location":"io/#io","text":"import {tap, o, pipe} from 'ramda'; var beautifyCpuOut = map(t => `${(t / 1.0e+6).toExponential()} sec`), cpu = of(process.cpuUsage), getDeltaCpu = previous => of(() => process.cpuUsage(previous)); pipe( () => cpu, map(tap(o(console.log, beautifyCpuOut))), chain(cpuOut => getDeltaCpu(cpuOut)), map(beautifyCpuOut), run )(); // -> { user: '4.923326e+0 sec', system: '1.297826e+0 sec' } // -> { user: '2.34e-4 sec', system: '2.1e-5 sec' }","title":"IO"},{"location":"license/","text":"The JSON License (JSON) Copyright (c) 2020-2021 Matthias Seemann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software shall be used for Good, not Evil. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"list/","text":"List By List is a synonym for Array-like collections. Although at this stage, @visisoft/staticland/list supports just Array as list type. If combining just data or functions with a \"list\", these functions (like map , chain , of , etc.) are provided by Ramda and thus will not be implemented here. However, when combining \"list\" with other algebraic types, unfortunately Ramda expects them to be Fantasy-Land objects with accordingly named methods. So, because Static-Land is all about static functions instead of member functions, @visisoft/staticland/list provides the following functions that work with combinations of \"list\" with the other @visisoft/staticland data \"types\". Searching find(predicate, list) :: (a \u2192 Boolean) \u2192 [a] \u2192 Maybe a Transformation sequence(of_f, liftA2_f, arrayOfF) :: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 [f a] \u2192 f [a] Swap the sequence of both the types List and a Functor: Turns a List of Functors of Values into a Functor of a List of Values. Example import {liftA2 as liftA2_mb, of as of_mb, nothing, just} from '@visisoft/staticland/maybe'; const listOfMaybesToMaybeOfList = sequence(of_mb, liftA2_mb); listOfMaybesToMaybeOfList([just(\"me\"), just(\"you\")]); // -> Just([\"me\", \"you\"]) listOfMaybesToMaybeOfList([just(\"me\"), nothing()]); // -> Nothing Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions. traverse(of_f, liftA2_f, effect_to_f, array) :: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 (a \u2192 f b) \u2192 [a] \u2192 f [b] Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions.","title":"List"},{"location":"list/#list","text":"By List is a synonym for Array-like collections. Although at this stage, @visisoft/staticland/list supports just Array as list type. If combining just data or functions with a \"list\", these functions (like map , chain , of , etc.) are provided by Ramda and thus will not be implemented here. However, when combining \"list\" with other algebraic types, unfortunately Ramda expects them to be Fantasy-Land objects with accordingly named methods. So, because Static-Land is all about static functions instead of member functions, @visisoft/staticland/list provides the following functions that work with combinations of \"list\" with the other @visisoft/staticland data \"types\".","title":"List"},{"location":"list/#searching","text":"","title":"Searching"},{"location":"list/#findpredicate-list","text":":: (a \u2192 Boolean) \u2192 [a] \u2192 Maybe a","title":"find(predicate, list)"},{"location":"list/#transformation","text":"","title":"Transformation"},{"location":"list/#sequenceof_f-lifta2_f-arrayoff","text":":: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 [f a] \u2192 f [a] Swap the sequence of both the types List and a Functor: Turns a List of Functors of Values into a Functor of a List of Values.","title":"sequence(of_f, liftA2_f, arrayOfF)"},{"location":"list/#example","text":"import {liftA2 as liftA2_mb, of as of_mb, nothing, just} from '@visisoft/staticland/maybe'; const listOfMaybesToMaybeOfList = sequence(of_mb, liftA2_mb); listOfMaybesToMaybeOfList([just(\"me\"), just(\"you\")]); // -> Just([\"me\", \"you\"]) listOfMaybesToMaybeOfList([just(\"me\"), nothing()]); // -> Nothing Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions.","title":"Example"},{"location":"list/#traverseof_f-lifta2_f-effect_to_f-array","text":":: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 (a \u2192 f b) \u2192 [a] \u2192 f [b] Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions.","title":"traverse(of_f, liftA2_f, effect_to_f, array)"},{"location":"maybe/","text":"Maybe Working with optional data, commonly done with if - else blocks. Native JavaScript arrays which are empty or have a single element are considered a Maybe here. Generators fromNilable :: (a|undefined|null) -> Maybe a Generates a maybe from a value which can be nullish. fromNilable({}.foo) // Nothing fromNilable(\"bar\") // Just(\"bar\") Consumption getOrElse(defaultValue) :: a -> Maybe a -> a Extract the value of a Just or return the provided default. getOrElse(\"foo\", nothing()); // -> \"foo\" getOrElse(\"foo\", just(\"bar\")); // -> \"bar\" Transformation sequence(of_f, map_f, MaybeOfF) :: Applicative f => ((a \u2192 f a), ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 Maybe (f a) \u2192 f (Maybe a) Swap the sequence of types: Maybe of Functor of Value to Functor of Maybe of Value. Maybe takes the role of a \"Traversable\" t . Examples Change a Maybe of a Promise into a Promise of a Maybe const // :: Maybe Promise e a -> Promise e Maybe a maybeOfPromiseToPromiseOfMaybe = sequence(of_p, map_p); maybeOfPromiseToPromiseOfMaybe(just(Promise.resolve(\"foo\"))); // -> Promise Just \"foo\" maybeOfPromiseToPromiseOfMaybe(just(Promise.reject(\"bar\"))); // -> Promise.reject(\"bar\") maybeOfPromiseToPromiseOfMaybe(nothing()); // -> Promise Nothing // getInputValue :: () -> Maybe string // fetchServer :: string -> Promise data // map_mb :: (a -> b) -> Maybe a -> Maybe b // defaultData :: data const // :: a -> Promise a of_p = value => Promise.resolve(value), // :: (a -> b) -> Promise a -> Promise b map_p = curry((fn, aPromise) => aPromise.then(fn)), // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String map_mb(fetchServer), // :: Maybe Promise Data maybeOfPromiseToPromiseOfMaybe, // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data ); Change a Maybe of a Key-Value Pair into a Key-Value Pair of a Maybe maybeOfFooObjectToObjectFooOfMaybe :: Maybe {foo: a} \u2192 {foo: Maybe a} import {modify, objOf} from 'ramda'; const ofFooObj = x => ({foo: x}), // :: a \u2192 {foo: a} mapFooObj = modify(\"foo\"), // :: (a \u2192 b) \u2192 {foo: a} \u2192 {foo: b} maybeOfFooObjectToObjectFooOfMaybe = // :: Maybe {foo: a} \u2192 {foo: Maybe a} sequence(ofFooObj, mapFooObj), justFooBar = just({foo: \"bar\"}); // :: Just {foo: \"bar\"} maybeOfFooObjectToObjectFooOfMaybe(justFooBar); // {foo: Maybe \"bar\"} traverse(of_f, map_f, effect_to_f, maybe) :: (Applicative f, Traversable t) => (c \u2192 f c) \u2192 ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 (a \u2192 f b) \u2192 Maybe a \u2192 f (Maybe b) Applies an \"effect\" effect_to_f to the value inside the Maybe. Then combines that \"effect\" with the Maybe by wrapping the \"effect's\" result in an Applicative of a Maybe. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a Promise of a Maybe than a Maybe of a Promise. Using traverse essentially combines mapping the effect_to_f over the Maybe and calling sequence(of_f, map_f) in a single step. // see first example for sequence const // :: (a \u2192 Promise b) \u2192 Maybe a \u2192 Promise Maybe b applyToPromiseOfMaybe = traverse(of_p, map_p), // :: a \u2192 Promise b delayEffect = x => new Promise(resolve => setTimeout(resolve, 1000, x)); applyToPromiseOfMaybe(delayEffect, just(\"foo\")); // -> Promise Just \"foo\" applyToPromiseOfMaybe(delayEffect, nothing()); // -> Promise Nothing // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String applyToPromiseOfMaybe(fetchServer), // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data ); Relation with sequence sequence(of_f, map_f, t) \u2261 traverse(of, map, identity, t) , and traverse(of_f, map_f, effect_to_f, t) \u2261 sequence(of_f, map_f, map(effect_to_f, t)) . The first two parameters of sequence and traverse are the same and due to the implementation. Caveats Argument type checking This library functions do not guard the user from supplying arguments of a wrong type. In particular, passing some other type as the maybe subject or passing a function to chain which returns a some other type, will cause undefined behaviour later. Value limitations Choosing empty and single-element arrays as implementation of the Maybe type causes these ambiguities: - A just and any single element array, - a nothing and any empty array cannot be distinguished. This directly affects the inspection functions isJust , isNothing and equals . E.g. equals(of(x), [x]) is true as well as equals(nothing(), []) is also true . Also join() will treat a just containing an empty array as a just containing nothing which is collapsed to a nothing. The library does not guard against these cases by inspecting value types at runtime. However, if the source code keeps track of the data type, e.g. join() should never been called with data of the wrong type (e.g. with a just of an array). Thus, such silent errors of join would never occur in practise. The other way around, recursively flattening an Array containing Maybes will destroy all Maybe elements. This can only be prevented by using Array.flat with the accurate deepness.","title":"Maybe"},{"location":"maybe/#maybe","text":"Working with optional data, commonly done with if - else blocks. Native JavaScript arrays which are empty or have a single element are considered a Maybe here.","title":"Maybe"},{"location":"maybe/#generators","text":"","title":"Generators"},{"location":"maybe/#fromnilable-aundefinednull-maybe-a","text":"Generates a maybe from a value which can be nullish. fromNilable({}.foo) // Nothing fromNilable(\"bar\") // Just(\"bar\")","title":"fromNilable :: (a|undefined|null) -&gt; Maybe a"},{"location":"maybe/#consumption","text":"","title":"Consumption"},{"location":"maybe/#getorelsedefaultvalue","text":":: a -> Maybe a -> a Extract the value of a Just or return the provided default. getOrElse(\"foo\", nothing()); // -> \"foo\" getOrElse(\"foo\", just(\"bar\")); // -> \"bar\"","title":"getOrElse(defaultValue)"},{"location":"maybe/#transformation","text":"","title":"Transformation"},{"location":"maybe/#sequenceof_f-map_f-maybeoff","text":":: Applicative f => ((a \u2192 f a), ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 Maybe (f a) \u2192 f (Maybe a) Swap the sequence of types: Maybe of Functor of Value to Functor of Maybe of Value. Maybe takes the role of a \"Traversable\" t .","title":"sequence(of_f, map_f, MaybeOfF)"},{"location":"maybe/#examples","text":"","title":"Examples"},{"location":"maybe/#change-a-maybe-of-a-promise-into-a-promise-of-a-maybe","text":"const // :: Maybe Promise e a -> Promise e Maybe a maybeOfPromiseToPromiseOfMaybe = sequence(of_p, map_p); maybeOfPromiseToPromiseOfMaybe(just(Promise.resolve(\"foo\"))); // -> Promise Just \"foo\" maybeOfPromiseToPromiseOfMaybe(just(Promise.reject(\"bar\"))); // -> Promise.reject(\"bar\") maybeOfPromiseToPromiseOfMaybe(nothing()); // -> Promise Nothing // getInputValue :: () -> Maybe string // fetchServer :: string -> Promise data // map_mb :: (a -> b) -> Maybe a -> Maybe b // defaultData :: data const // :: a -> Promise a of_p = value => Promise.resolve(value), // :: (a -> b) -> Promise a -> Promise b map_p = curry((fn, aPromise) => aPromise.then(fn)), // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String map_mb(fetchServer), // :: Maybe Promise Data maybeOfPromiseToPromiseOfMaybe, // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data );","title":"Change a Maybe of a Promise into a Promise of a Maybe"},{"location":"maybe/#change-a-maybe-of-a-key-value-pair-into-a-key-value-pair-of-a-maybe","text":"maybeOfFooObjectToObjectFooOfMaybe :: Maybe {foo: a} \u2192 {foo: Maybe a} import {modify, objOf} from 'ramda'; const ofFooObj = x => ({foo: x}), // :: a \u2192 {foo: a} mapFooObj = modify(\"foo\"), // :: (a \u2192 b) \u2192 {foo: a} \u2192 {foo: b} maybeOfFooObjectToObjectFooOfMaybe = // :: Maybe {foo: a} \u2192 {foo: Maybe a} sequence(ofFooObj, mapFooObj), justFooBar = just({foo: \"bar\"}); // :: Just {foo: \"bar\"} maybeOfFooObjectToObjectFooOfMaybe(justFooBar); // {foo: Maybe \"bar\"}","title":"Change a Maybe of a Key-Value Pair into a Key-Value Pair of a Maybe"},{"location":"maybe/#traverseof_f-map_f-effect_to_f-maybe","text":":: (Applicative f, Traversable t) => (c \u2192 f c) \u2192 ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 (a \u2192 f b) \u2192 Maybe a \u2192 f (Maybe b) Applies an \"effect\" effect_to_f to the value inside the Maybe. Then combines that \"effect\" with the Maybe by wrapping the \"effect's\" result in an Applicative of a Maybe. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a Promise of a Maybe than a Maybe of a Promise. Using traverse essentially combines mapping the effect_to_f over the Maybe and calling sequence(of_f, map_f) in a single step. // see first example for sequence const // :: (a \u2192 Promise b) \u2192 Maybe a \u2192 Promise Maybe b applyToPromiseOfMaybe = traverse(of_p, map_p), // :: a \u2192 Promise b delayEffect = x => new Promise(resolve => setTimeout(resolve, 1000, x)); applyToPromiseOfMaybe(delayEffect, just(\"foo\")); // -> Promise Just \"foo\" applyToPromiseOfMaybe(delayEffect, nothing()); // -> Promise Nothing // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String applyToPromiseOfMaybe(fetchServer), // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data );","title":"traverse(of_f, map_f, effect_to_f, maybe)"},{"location":"maybe/#relation-with-sequence","text":"sequence(of_f, map_f, t) \u2261 traverse(of, map, identity, t) , and traverse(of_f, map_f, effect_to_f, t) \u2261 sequence(of_f, map_f, map(effect_to_f, t)) . The first two parameters of sequence and traverse are the same and due to the implementation.","title":"Relation with sequence"},{"location":"maybe/#caveats","text":"","title":"Caveats"},{"location":"maybe/#argument-type-checking","text":"This library functions do not guard the user from supplying arguments of a wrong type. In particular, passing some other type as the maybe subject or passing a function to chain which returns a some other type, will cause undefined behaviour later.","title":"Argument type checking"},{"location":"maybe/#value-limitations","text":"Choosing empty and single-element arrays as implementation of the Maybe type causes these ambiguities: - A just and any single element array, - a nothing and any empty array cannot be distinguished. This directly affects the inspection functions isJust , isNothing and equals . E.g. equals(of(x), [x]) is true as well as equals(nothing(), []) is also true . Also join() will treat a just containing an empty array as a just containing nothing which is collapsed to a nothing. The library does not guard against these cases by inspecting value types at runtime. However, if the source code keeps track of the data type, e.g. join() should never been called with data of the wrong type (e.g. with a just of an array). Thus, such silent errors of join would never occur in practise. The other way around, recursively flattening an Array containing Maybes will destroy all Maybe elements. This can only be prevented by using Array.flat with the accurate deepness.","title":"Value limitations"},{"location":"promise/","text":"Promise Represents the eventual outcome or failure of an eagerly executed computation. Related Work and Inspiration Applicative Functors , Futures Generation later(dt, a) :: number \u2192 a \u2192 Promise a of(a) :: a -> Promise e a Consumption Side-Effects bi_tap(onFailure, onSuccess, p) :: (* -> *) -> (a -> *) -> Promise a -> Promise a Like tap but also with a failure side-effect function. tap(fn, p) :: (a -> *) -> Promise a -> Promise a In this implementation an exception in the side-effect fn rubs off to the Promise. tapRegardless(fn, p) :: (a -> *) -> Promise a -> Promise a Execute a synchronous side effect. Aka forEach . In this implementation an exception in the side-effect is ignored. promise X ---------> X ---> \\ - fn(X) -> Y Transformation","title":"Promise"},{"location":"promise/#promise","text":"Represents the eventual outcome or failure of an eagerly executed computation.","title":"Promise"},{"location":"promise/#related-work-and-inspiration","text":"Applicative Functors , Futures","title":"Related Work and Inspiration"},{"location":"promise/#generation","text":"","title":"Generation"},{"location":"promise/#laterdt-a","text":":: number \u2192 a \u2192 Promise a","title":"later(dt, a)"},{"location":"promise/#ofa","text":":: a -> Promise e a","title":"of(a)"},{"location":"promise/#consumption","text":"","title":"Consumption"},{"location":"promise/#side-effects","text":"","title":"Side-Effects"},{"location":"promise/#bi_taponfailure-onsuccess-p","text":":: (* -> *) -> (a -> *) -> Promise a -> Promise a Like tap but also with a failure side-effect function.","title":"bi_tap(onFailure, onSuccess, p)"},{"location":"promise/#tapfn-p","text":":: (a -> *) -> Promise a -> Promise a In this implementation an exception in the side-effect fn rubs off to the Promise.","title":"tap(fn, p)"},{"location":"promise/#tapregardlessfn-p","text":":: (a -> *) -> Promise a -> Promise a Execute a synchronous side effect. Aka forEach . In this implementation an exception in the side-effect is ignored. promise X ---------> X ---> \\ - fn(X) -> Y","title":"tapRegardless(fn, p)"},{"location":"promise/#transformation","text":"","title":"Transformation"},{"location":"transformations/","text":"Natural Transformations Extracting from/Wrapping with Collections keyMaybeToMaybeObj(key, coll) :: key -> {key: Maybe a, \u2026} -> Maybe {key: a, \u2026} :: Idx -> [Idx: Maybe a, \u2026] -> Maybe [Idx: a, \u2026] Async Stuff maybeOfPromiseToPromiseOfMaybe(promiseOfMaybe) :: Maybe Promise e a -> Promise e Maybe a deprecated instead use maybe/sequence(of_p, map_p) maybeOfCancelableToCancelableOfMaybe(mma) :: Maybe Cancelable e a -> Cancelable e Maybe a eitherToCancelable(either) :: Either e a \u2192 Cancelable e a promiseToCancelable(promise) :: Promise e a \u2192 Cancelable e a The transformation is with limitations: - Eagerness cannot be transformed into laziness, i.e. the computation represented by the promise is already executing or even settled. - The computation cannot be cancelled. Cancelling the resulting Cancelable will simply prevent the continuation callbacks from getting called once the promise settles. cancelableToPromise(cancelable) :: Cancelable e a \u2192 Promise e a Since promises are eager, this transformation will run the cancelable computation. The ability to cancel the computation will be lost. Note that in principle, the ability to cancel the computation could be maintained. However, a result of the cancellation would then be that the created Promise never settles. That is considered to be bad practise. Async into/from Reactive Streams cancelableToEventStream(cancelable) :: Cancelable e a \u2192 EventStream e a Creates a single-valued Bacon.js EventStream observable. observableToCancelable(observable) :: Observable e a \u2192 Cancelable e a cancelableToMostStream(cancelable) :: Cancelable a \u2192 Stream a Crates a single-valued @most/core Stream . mostStreamToCancelable(stream) :: Stream a \u2192 Cancelable a If not cancelled the resulting Cancelable Computation will continue with the last value, or the first error in the stream. Maybe/Either into/from Reactive Streams maybeOfBaconObservableToBaconObservableOfMaybe(maybeObservable) :: Maybe Observable a -> Observable Maybe a","title":"Transformations"},{"location":"transformations/#natural-transformations","text":"","title":"Natural Transformations"},{"location":"transformations/#extracting-fromwrapping-with-collections","text":"","title":"Extracting from/Wrapping with Collections"},{"location":"transformations/#keymaybetomaybeobjkey-coll","text":":: key -> {key: Maybe a, \u2026} -> Maybe {key: a, \u2026} :: Idx -> [Idx: Maybe a, \u2026] -> Maybe [Idx: a, \u2026]","title":"keyMaybeToMaybeObj(key, coll)"},{"location":"transformations/#async-stuff","text":"","title":"Async Stuff"},{"location":"transformations/#maybeofpromisetopromiseofmaybepromiseofmaybe","text":":: Maybe Promise e a -> Promise e Maybe a deprecated instead use maybe/sequence(of_p, map_p)","title":"maybeOfPromiseToPromiseOfMaybe(promiseOfMaybe)"},{"location":"transformations/#maybeofcancelabletocancelableofmaybemma","text":":: Maybe Cancelable e a -> Cancelable e Maybe a","title":"maybeOfCancelableToCancelableOfMaybe(mma)"},{"location":"transformations/#eithertocancelableeither","text":":: Either e a \u2192 Cancelable e a","title":"eitherToCancelable(either)"},{"location":"transformations/#promisetocancelablepromise","text":":: Promise e a \u2192 Cancelable e a The transformation is with limitations: - Eagerness cannot be transformed into laziness, i.e. the computation represented by the promise is already executing or even settled. - The computation cannot be cancelled. Cancelling the resulting Cancelable will simply prevent the continuation callbacks from getting called once the promise settles.","title":"promiseToCancelable(promise)"},{"location":"transformations/#cancelabletopromisecancelable","text":":: Cancelable e a \u2192 Promise e a Since promises are eager, this transformation will run the cancelable computation. The ability to cancel the computation will be lost. Note that in principle, the ability to cancel the computation could be maintained. However, a result of the cancellation would then be that the created Promise never settles. That is considered to be bad practise.","title":"cancelableToPromise(cancelable)"},{"location":"transformations/#async-intofrom-reactive-streams","text":"","title":"Async into/from Reactive Streams"},{"location":"transformations/#cancelabletoeventstreamcancelable","text":":: Cancelable e a \u2192 EventStream e a Creates a single-valued Bacon.js EventStream observable.","title":"cancelableToEventStream(cancelable)"},{"location":"transformations/#observabletocancelableobservable","text":":: Observable e a \u2192 Cancelable e a","title":"observableToCancelable(observable)"},{"location":"transformations/#cancelabletomoststreamcancelable","text":":: Cancelable a \u2192 Stream a Crates a single-valued @most/core Stream .","title":"cancelableToMostStream(cancelable)"},{"location":"transformations/#moststreamtocancelablestream","text":":: Stream a \u2192 Cancelable a If not cancelled the resulting Cancelable Computation will continue with the last value, or the first error in the stream.","title":"mostStreamToCancelable(stream)"},{"location":"transformations/#maybeeither-intofrom-reactive-streams","text":"","title":"Maybe/Either into/from Reactive Streams"},{"location":"transformations/#maybeofbaconobservabletobaconobservableofmaybemaybeobservable","text":":: Maybe Observable a -> Observable Maybe a","title":"maybeOfBaconObservableToBaconObservableOfMaybe(maybeObservable)"}]}