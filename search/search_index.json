{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"@visisoft/staticland v0.2.0 Support programming in functional pipelines by exposing a familiar set of operations on asynchronous, optional and faulty data. Operations (Transforming, Lensing, Combination, etc.) on Algebraic Data Types (ADT) ( Either , Maybe , Promise , CancelableComputation ) provided as sets free static functions . Motivation For the motivation I'd like to refer to James Sinclair's post on StaticLand . Data Types Each set of these free static functions expect a particular data-holding type. @visisoft/staticland is very un-opinionated about the data type. E.g. the operations on non-cancelable computations simply expect a Promise as data type. This makes crossing the boundary into and out of @visisoft/staticland especially easy. Each data type represents a particular computational feature or aspect of programming . For instance an optional value is a Maybe , and a CancelableComputation represents just that. @visisoft/staticland does not \"provide\" data types e.g. as classes for these computational features . It is not productive to find the best implementation of a data type. The function sets of @visisoft/staticland choose to operate on just the simplest JavaScript objects \u2013 Array , Function or (as already mentioned) Promise . In Functional Programming (FP) factory and consumption functions are provided to interface with external code. Sets of Operations To its particular data type, each set of operations permit the transforming, the combining, the iterating or the focusing on an item of the data structure. Thus, the sets of operations have a lot in common \u2013 e.g. each have the functions map , and chain . Admittedly, this brings an inflation to the api surface when working with different data types. Also, since each use of e.g. map or chain is targeted to a particular data type, the operations must be carefully placed, so that with nested data types the sequence of operations reflects the structure of the nested data exactly. On the other hand, the current data type can be derived by looking at the code, using the TypeScript signatures, the code inspector can deduce the type correctness, and third-party data types can be integrated in this concept without altering or augmenting their provided data type, but by simply writing another set of operations. FantasyLand It is worth mentioning the competing concept of FantasyLand . It features a unified set of operations which operate on all compatible data types. It does so be enforcing compatible data types to implement a particular protocol \u2013 i.e. carefully named object methods. The free static functions of FantasyLand are just a shell which delegates to the operation implemented in the particular method of the data object. One prominent provider of such shell functions is the FP toolkit Ramda . Behind the promising advantage of having a unified set of operations, FantasyLand has drawbacks. Even among Ramda users its adoption is not 100% which this comment illustrates. Library authors need to be convinced to understand the FantasyLand protocol and implement it in their data types. Often libraries already provide free static functions like map and chain tailored to their data type. These integrate nicely with the StaticLand concept. The FantasyLand specification has several versions, allowing for a possible mismatch between FP toolkit and the data type library In the search to overcome these drawbacks the concept of StaticLand was discovered. Both concepts are compared in an article by James Sinclair . Homepage and Documentation Hello @visisoft/staticland Installation When developing for Node.js npm install @visisoft/staticland When developing for the browser npm install --no-optional @visisoft/staticland Hello Earth Greeting with a 0.5 sec 2-way delay. Usage in an ES module import {map as map_p, mapRej as mapRej_p, chain as chain_p} from '@visisoft/staticland/promise'; import {fromThrowable} from '@visisoft/staticland/either'; import {fromNilable, getOrElse} from '@visisoft/staticland/maybe'; import {curry, pipe} from 'ramda'; // or pipe from 'crocks' or any other composition function const // :: String -> {k: String} -> Maybe String getProperty = R.curry((property, object) => fromNilable(object[property])), // :: a -> Promise any a delay = x => new Promise(resolve => setTimeout(resolve, 500, x)), // :: any -> Either Error String safeGreet = fromThrowable(x => \"Hello \" + x.toString() + \"!\"), // :: any -> Promise (Maybe String) String getAnswer = R.pipe( delay, // Promise any any map_p(safeGreet), // Promise any (Either Error String) chain_p(delay), // Promise any (Either Error String) chain_p(eitherToPromise), // Promise (any|Error) String mapRej_p(getProperty('message')) // Promise (Maybe String) String ); getAnswer(\"Earth\") .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Hello Earth!\" getAnswer(null) .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Cannot read property 'toString' of null\" Usage in a CommonJS module const {chain: chain_p} = require('@visisoft/staticland/promise'), delay = t => x => new Promise(resolve => setTimeout(resolve, t, x)); chain(delay(500), Promise.resolve(\"foo\")).then(console.log); Design Most functions comply with Static-Land `s algebraic laws. Where this is not possible (e.g. nesting of resolved Promises) a few reasonable paradigms have to be followed when using this library. At the expense of complete algebraic lawfulness the data wrapping remains transparent and light-weight. The functions are designed to support the usual functional programming style in JavaScript as it is the design philosophy for many libraries for example Ramda's : Emphasise a purer functional style. Immutability and side-effect free functions help to write simple yet elegant code. Automatic currying. This allows you to easily build up new functions from old ones simply by not supplying the final parameters. Parameter order supports convenient currying. The data to be operated on is generally supplied last, so that it's easy to create functional pipelines by composing functions . Related Fantasy-Land Libraries Ramda-Fantasy is very well documented, but sadly no longer maintained. Crocks is an exemplary implementation of common data types. Dependencies As FP utility library Ramda is used. Implementation Details of map chain Consumption CancelableComputation cc = (resolve, reject) => () => () new Promise(cc) Either x => [,x] Array.prototype.map Array.prototype.flatMap xs => xs[1] Maybe x => [x] Array.prototype.map Array.prototype.flatMap xs => xs[0] Promise Promise.resolve Promise.then Promise.then Promise.then IO x => x compose run(compose) call closed over A closure is the combination of a function and the lexical environment within which that function was declared.","title":"Welcome"},{"location":"#visisoftstaticland-v020","text":"Support programming in functional pipelines by exposing a familiar set of operations on asynchronous, optional and faulty data. Operations (Transforming, Lensing, Combination, etc.) on Algebraic Data Types (ADT) ( Either , Maybe , Promise , CancelableComputation ) provided as sets free static functions .","title":"@visisoft/staticland v0.2.0"},{"location":"#motivation","text":"For the motivation I'd like to refer to James Sinclair's post on StaticLand .","title":"Motivation"},{"location":"#data-types","text":"Each set of these free static functions expect a particular data-holding type. @visisoft/staticland is very un-opinionated about the data type. E.g. the operations on non-cancelable computations simply expect a Promise as data type. This makes crossing the boundary into and out of @visisoft/staticland especially easy. Each data type represents a particular computational feature or aspect of programming . For instance an optional value is a Maybe , and a CancelableComputation represents just that. @visisoft/staticland does not \"provide\" data types e.g. as classes for these computational features . It is not productive to find the best implementation of a data type. The function sets of @visisoft/staticland choose to operate on just the simplest JavaScript objects \u2013 Array , Function or (as already mentioned) Promise . In Functional Programming (FP) factory and consumption functions are provided to interface with external code.","title":"Data Types"},{"location":"#sets-of-operations","text":"To its particular data type, each set of operations permit the transforming, the combining, the iterating or the focusing on an item of the data structure. Thus, the sets of operations have a lot in common \u2013 e.g. each have the functions map , and chain . Admittedly, this brings an inflation to the api surface when working with different data types. Also, since each use of e.g. map or chain is targeted to a particular data type, the operations must be carefully placed, so that with nested data types the sequence of operations reflects the structure of the nested data exactly. On the other hand, the current data type can be derived by looking at the code, using the TypeScript signatures, the code inspector can deduce the type correctness, and third-party data types can be integrated in this concept without altering or augmenting their provided data type, but by simply writing another set of operations.","title":"Sets of Operations"},{"location":"#fantasyland","text":"It is worth mentioning the competing concept of FantasyLand . It features a unified set of operations which operate on all compatible data types. It does so be enforcing compatible data types to implement a particular protocol \u2013 i.e. carefully named object methods. The free static functions of FantasyLand are just a shell which delegates to the operation implemented in the particular method of the data object. One prominent provider of such shell functions is the FP toolkit Ramda . Behind the promising advantage of having a unified set of operations, FantasyLand has drawbacks. Even among Ramda users its adoption is not 100% which this comment illustrates. Library authors need to be convinced to understand the FantasyLand protocol and implement it in their data types. Often libraries already provide free static functions like map and chain tailored to their data type. These integrate nicely with the StaticLand concept. The FantasyLand specification has several versions, allowing for a possible mismatch between FP toolkit and the data type library In the search to overcome these drawbacks the concept of StaticLand was discovered. Both concepts are compared in an article by James Sinclair .","title":"FantasyLand"},{"location":"#homepage-and-documentation","text":"","title":"Homepage and Documentation"},{"location":"#hello-visisoftstaticland","text":"","title":"Hello @visisoft/staticland"},{"location":"#installation","text":"When developing for Node.js npm install @visisoft/staticland When developing for the browser npm install --no-optional @visisoft/staticland","title":"Installation"},{"location":"#hello-earth","text":"Greeting with a 0.5 sec 2-way delay.","title":"Hello Earth"},{"location":"#usage-in-an-es-module","text":"import {map as map_p, mapRej as mapRej_p, chain as chain_p} from '@visisoft/staticland/promise'; import {fromThrowable} from '@visisoft/staticland/either'; import {fromNilable, getOrElse} from '@visisoft/staticland/maybe'; import {curry, pipe} from 'ramda'; // or pipe from 'crocks' or any other composition function const // :: String -> {k: String} -> Maybe String getProperty = R.curry((property, object) => fromNilable(object[property])), // :: a -> Promise any a delay = x => new Promise(resolve => setTimeout(resolve, 500, x)), // :: any -> Either Error String safeGreet = fromThrowable(x => \"Hello \" + x.toString() + \"!\"), // :: any -> Promise (Maybe String) String getAnswer = R.pipe( delay, // Promise any any map_p(safeGreet), // Promise any (Either Error String) chain_p(delay), // Promise any (Either Error String) chain_p(eitherToPromise), // Promise (any|Error) String mapRej_p(getProperty('message')) // Promise (Maybe String) String ); getAnswer(\"Earth\") .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Hello Earth!\" getAnswer(null) .then(console.log, me => console.warn(getOrElse(\"unknown error\", me))); // -> \"Cannot read property 'toString' of null\"","title":"Usage in an ES module"},{"location":"#usage-in-a-commonjs-module","text":"const {chain: chain_p} = require('@visisoft/staticland/promise'), delay = t => x => new Promise(resolve => setTimeout(resolve, t, x)); chain(delay(500), Promise.resolve(\"foo\")).then(console.log);","title":"Usage in a CommonJS module"},{"location":"#design","text":"Most functions comply with Static-Land `s algebraic laws. Where this is not possible (e.g. nesting of resolved Promises) a few reasonable paradigms have to be followed when using this library. At the expense of complete algebraic lawfulness the data wrapping remains transparent and light-weight. The functions are designed to support the usual functional programming style in JavaScript as it is the design philosophy for many libraries for example Ramda's : Emphasise a purer functional style. Immutability and side-effect free functions help to write simple yet elegant code. Automatic currying. This allows you to easily build up new functions from old ones simply by not supplying the final parameters. Parameter order supports convenient currying. The data to be operated on is generally supplied last, so that it's easy to create functional pipelines by composing functions .","title":"Design"},{"location":"#related-fantasy-land-libraries","text":"Ramda-Fantasy is very well documented, but sadly no longer maintained. Crocks is an exemplary implementation of common data types.","title":"Related Fantasy-Land Libraries"},{"location":"#dependencies","text":"As FP utility library Ramda is used.","title":"Dependencies"},{"location":"#implementation-details","text":"of map chain Consumption CancelableComputation cc = (resolve, reject) => () => () new Promise(cc) Either x => [,x] Array.prototype.map Array.prototype.flatMap xs => xs[1] Maybe x => [x] Array.prototype.map Array.prototype.flatMap xs => xs[0] Promise Promise.resolve Promise.then Promise.then Promise.then IO x => x compose run(compose) call","title":"Implementation Details"},{"location":"#closed-over","text":"A closure is the combination of a function and the lexical environment within which that function was declared.","title":"closed over"},{"location":"cancelable-api/","text":"Cancelable Computation Signature CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) Leaving the failure type to be implicitly an Error the signature can be shortened: CancelableComputation a :: ((a -> void), (* -> void)) -> (() -> void) Generator Functions Custom Cancelable Every function taking two callbacks as arguments; a success callback, and a failure callback which returns an abort function, and which calls one of the callbacks asynchronously is a Cancelable . let cancelableWork = (res, rej) => { const work = beginSomeLongWork(); whenCompletedWithResult(work, result => res(result)); whenFailedWorkWithError(work, error => res(error)); return () => { abort(work); }; }; of(value) :: a -> Cancelable () a reject(e) :: e => Cancelable e () never() :: () -> Cancelable () () Creates a Cancelable which executes nothing and never settles. later(dt, value) :: Number -> a -> Cancelable () a laterReject(dt, e) :: Number -> e -> Cancelable e () cancelify(f) :: (*... \u2192 Promise e a) \u2192 *... \u2192 Cancelable e a Takes a function f which generates a non-abort-/non-cancel-able Promise and returns a function with the same arguments but which returns a Cancelable. The computation cannot be cancelled. Cancelling the resulting Cancelable will simply prevent the continuation callbacks from getting called once the promise settles. See promiseToCancelable . fetchResponse({url, fetchSpec}) via fetchResponseIsoModule :: {url: (String|URL), init: {}} -> Cancelable Error Response This example fetches the number of libraries hosted at cdnjs.com . The result is a Cancelable of a Maybe of a Number. The - failure continuation of the cancelable contains network errors and errors in the JSON format of the response, - nothing path of the maybe is taken in case the combined network and parse duration exceeded the timeout , - the just path of the Maybe in the success continuation of the Cancelable contains the result . import {ap, pair, pipe} from 'ramda'; import {chain as chain_c, later, map as map_c, fetchResponseIsoModule} from '@visisoft/staticland/cancelable'; import { eitherToCancelable, keyPromiseToPromiseCollection, promiseToCancelable } from '@visisoft/staticland/transformations'; import { chain as chain_e, right, left } from '@visisoft/staticland/either'; import {nothing, just, maybe } from '@visisoft/staticland/maybe'; // assume we are running in Node.js import fetch from 'node-fetch'; import AbortController from \"abort-controller\"; const // :: {url: (String|URL), init: {}} -> Cancelable Error Response fetchResponse = fetchResponseIsoModule({fetch, AbortController}), // in a Browser this would be fetchResponse = fetchResponseIsoModule(globalThis); // :: Pair Response {k:v} -> Either {k:v} checkFetchResponseWithPayload = ([response, payload]) => response.ok ? right(payload) : left({ message: response.statusText, code: response.status, payload }), // :: {k:v} -> Either Number checkStatsResult = payload => typeof payload.libraries === \"number\" ? right(payload.libaries) : left({ message: \"Unexpected API response\", payload }), // :: Cancelable Maybe Number numberOfCDNJSLibraries = pipe( () => fetchResponse({url: \"https://api.cdnjs.com/stats\", init: { mode: \"cors\" }}), // :: Cancelable Response map_c(ap(pair, response => response.json())), // :: Cancelable Pair (Response) (Promise {k:v}) map_c(keyPromiseToPromiseCollection(1)), // :: Cancelable Promise Pair (Response) ({k:v}) chain_c(promiseToCancelable), // :: Cancelable Pair (Response) ({k:v}) map_c(checkFetchResponseWithPayload), // :: Cancelable Either {k:v} map_c(chain_e(checkStatsResult)), // :: Cancelable Either Number chain_c(eitherToCancelable), // :: Cancelable Number map_c(just), // :: Cancelable Maybe Number race(later(1000, nothing())), // :: Cancelable Maybe Number )(); new Promise(numberOfCDNJSLibraries) // running .then( // consuming maybeCount => { console.log(maybe( () => \"Info: API request did not complete in time.\", n => `Result: CDNJS hosts ${n} libraries.`, maybeCount )); }, error => { console.log(`Error: fetching CNDJSAPI: \"${error.message}\".\\nData received:\"${JSON.stringify(error.payload)}\"`); } ); Transformation coalesce(onFailure, onSuccess, cancelable) :: Cancelable c \u21d2 (* \u2192 b) \u2192 (a \u2192 b) \u2192 c a \u2192 c b Maps failure via onFailure and success via onSuccess to new success value. map(f, cancelable) :: Cancelable c \u21d2 (a \u2192 b) \u2192 c a \u2192 c b pluck(key) :: Cancelable c \u21d2 k \u2192 c {k: v} \u2192 c v :: Cancelable c \u21d2 number \u2192 c [v] \u2192 c v Simply k => map(R.prop(k)) for mapping to a key value. Deprecated use pluck from Ramda via fantasy-land api. chain(f, cancelable) :: (a \u2192 Cancelable b) \u2192 Cancelable a \u2192 Cancelable \u2192 b Side-Effects bi_tap(onFailure, onSuccess) :: (e -> *) -> (a -> *) -> Cancelable e a -> Cancelable e a If either function throws an error, the present outcome is replaced by a failure given of that error. Combinations ap(cancelableFunc, cancelable) :: Cancelable (a \u2192 b) \u2192 Cancelable a \u2192 Cancelable b Parallel running version: It runs both Cancelable arguments in parallel. Note that if it was implemented simply ap(mf, ma) = chain(f => map(f, ma), mf) will not run the Cancelable Computations in parallel . liftA2(f, ccA , ccB) :: (a \u2192 b \u2192 c) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c Equivalent to (f, pa, pb) => Promise.all([pa, pb]).then(([a, b]) => f(a, b)) . f must be curried. Note that when implemented by sequentially running ap , liftA2(f, ma, mb) = ap(map(f, ma), mb) will not run the Cancelable Computations in parallel . liftA3(f, ccA , ccB, ccC) :: (a \u2192 b \u2192 c \u2192 d) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c \u2192 Cancelable d liftA4(f, ccA , ccB, ccC, ccD) :: (a \u2192 b \u2192 c \u2192 d \u2192 e) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c \u2192 Cancelable d \u2192 Cancelable e race(cancelableA, cancelableB) :: Cancelable a \u2192 Cancelable a \u2192 Cancelable a Like Promise.race shortcuts (i.e. aborts the other) when any input value is settled with success or failure. Utility share(cancelable) :: Cancelable e a \u2192 Cancelable e a Caches the computational result for sharing with many consumers without the need for re-computation. See the section on Copying/Sharing Cancelables and it's role model Fluture.cache .","title":"Cancelable"},{"location":"cancelable-api/#cancelable-computation","text":"","title":"Cancelable Computation"},{"location":"cancelable-api/#signature","text":"CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) Leaving the failure type to be implicitly an Error the signature can be shortened: CancelableComputation a :: ((a -> void), (* -> void)) -> (() -> void)","title":"Signature"},{"location":"cancelable-api/#generator-functions","text":"","title":"Generator Functions"},{"location":"cancelable-api/#custom-cancelable","text":"Every function taking two callbacks as arguments; a success callback, and a failure callback which returns an abort function, and which calls one of the callbacks asynchronously is a Cancelable . let cancelableWork = (res, rej) => { const work = beginSomeLongWork(); whenCompletedWithResult(work, result => res(result)); whenFailedWorkWithError(work, error => res(error)); return () => { abort(work); }; };","title":"Custom Cancelable"},{"location":"cancelable-api/#ofvalue","text":":: a -> Cancelable () a","title":"of(value)"},{"location":"cancelable-api/#rejecte","text":":: e => Cancelable e ()","title":"reject(e)"},{"location":"cancelable-api/#never","text":":: () -> Cancelable () () Creates a Cancelable which executes nothing and never settles.","title":"never()"},{"location":"cancelable-api/#laterdt-value","text":":: Number -> a -> Cancelable () a","title":"later(dt, value)"},{"location":"cancelable-api/#laterrejectdt-e","text":":: Number -> e -> Cancelable e ()","title":"laterReject(dt, e)"},{"location":"cancelable-api/#cancelifyf","text":":: (*... \u2192 Promise e a) \u2192 *... \u2192 Cancelable e a Takes a function f which generates a non-abort-/non-cancel-able Promise and returns a function with the same arguments but which returns a Cancelable. The computation cannot be cancelled. Cancelling the resulting Cancelable will simply prevent the continuation callbacks from getting called once the promise settles. See promiseToCancelable .","title":"cancelify(f)"},{"location":"cancelable-api/#fetchresponseurl-fetchspec-via-fetchresponseisomodule","text":":: {url: (String|URL), init: {}} -> Cancelable Error Response This example fetches the number of libraries hosted at cdnjs.com . The result is a Cancelable of a Maybe of a Number. The - failure continuation of the cancelable contains network errors and errors in the JSON format of the response, - nothing path of the maybe is taken in case the combined network and parse duration exceeded the timeout , - the just path of the Maybe in the success continuation of the Cancelable contains the result . import {ap, pair, pipe} from 'ramda'; import {chain as chain_c, later, map as map_c, fetchResponseIsoModule} from '@visisoft/staticland/cancelable'; import { eitherToCancelable, keyPromiseToPromiseCollection, promiseToCancelable } from '@visisoft/staticland/transformations'; import { chain as chain_e, right, left } from '@visisoft/staticland/either'; import {nothing, just, maybe } from '@visisoft/staticland/maybe'; // assume we are running in Node.js import fetch from 'node-fetch'; import AbortController from \"abort-controller\"; const // :: {url: (String|URL), init: {}} -> Cancelable Error Response fetchResponse = fetchResponseIsoModule({fetch, AbortController}), // in a Browser this would be fetchResponse = fetchResponseIsoModule(globalThis); // :: Pair Response {k:v} -> Either {k:v} checkFetchResponseWithPayload = ([response, payload]) => response.ok ? right(payload) : left({ message: response.statusText, code: response.status, payload }), // :: {k:v} -> Either Number checkStatsResult = payload => typeof payload.libraries === \"number\" ? right(payload.libaries) : left({ message: \"Unexpected API response\", payload }), // :: Cancelable Maybe Number numberOfCDNJSLibraries = pipe( () => fetchResponse({url: \"https://api.cdnjs.com/stats\", init: { mode: \"cors\" }}), // :: Cancelable Response map_c(ap(pair, response => response.json())), // :: Cancelable Pair (Response) (Promise {k:v}) map_c(keyPromiseToPromiseCollection(1)), // :: Cancelable Promise Pair (Response) ({k:v}) chain_c(promiseToCancelable), // :: Cancelable Pair (Response) ({k:v}) map_c(checkFetchResponseWithPayload), // :: Cancelable Either {k:v} map_c(chain_e(checkStatsResult)), // :: Cancelable Either Number chain_c(eitherToCancelable), // :: Cancelable Number map_c(just), // :: Cancelable Maybe Number race(later(1000, nothing())), // :: Cancelable Maybe Number )(); new Promise(numberOfCDNJSLibraries) // running .then( // consuming maybeCount => { console.log(maybe( () => \"Info: API request did not complete in time.\", n => `Result: CDNJS hosts ${n} libraries.`, maybeCount )); }, error => { console.log(`Error: fetching CNDJSAPI: \"${error.message}\".\\nData received:\"${JSON.stringify(error.payload)}\"`); } );","title":"fetchResponse({url, fetchSpec}) via fetchResponseIsoModule"},{"location":"cancelable-api/#transformation","text":"","title":"Transformation"},{"location":"cancelable-api/#coalesceonfailure-onsuccess-cancelable","text":":: Cancelable c \u21d2 (* \u2192 b) \u2192 (a \u2192 b) \u2192 c a \u2192 c b Maps failure via onFailure and success via onSuccess to new success value.","title":"coalesce(onFailure, onSuccess, cancelable)"},{"location":"cancelable-api/#mapf-cancelable","text":":: Cancelable c \u21d2 (a \u2192 b) \u2192 c a \u2192 c b","title":"map(f, cancelable)"},{"location":"cancelable-api/#pluckkey","text":":: Cancelable c \u21d2 k \u2192 c {k: v} \u2192 c v :: Cancelable c \u21d2 number \u2192 c [v] \u2192 c v Simply k => map(R.prop(k)) for mapping to a key value. Deprecated use pluck from Ramda via fantasy-land api.","title":"pluck(key)"},{"location":"cancelable-api/#chainf-cancelable","text":":: (a \u2192 Cancelable b) \u2192 Cancelable a \u2192 Cancelable \u2192 b","title":"chain(f, cancelable)"},{"location":"cancelable-api/#side-effects","text":"","title":"Side-Effects"},{"location":"cancelable-api/#bi_taponfailure-onsuccess","text":":: (e -> *) -> (a -> *) -> Cancelable e a -> Cancelable e a If either function throws an error, the present outcome is replaced by a failure given of that error.","title":"bi_tap(onFailure, onSuccess)"},{"location":"cancelable-api/#combinations","text":"","title":"Combinations"},{"location":"cancelable-api/#apcancelablefunc-cancelable","text":":: Cancelable (a \u2192 b) \u2192 Cancelable a \u2192 Cancelable b Parallel running version: It runs both Cancelable arguments in parallel. Note that if it was implemented simply ap(mf, ma) = chain(f => map(f, ma), mf) will not run the Cancelable Computations in parallel .","title":"ap(cancelableFunc, cancelable)"},{"location":"cancelable-api/#lifta2f-cca-ccb","text":":: (a \u2192 b \u2192 c) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c Equivalent to (f, pa, pb) => Promise.all([pa, pb]).then(([a, b]) => f(a, b)) . f must be curried. Note that when implemented by sequentially running ap , liftA2(f, ma, mb) = ap(map(f, ma), mb) will not run the Cancelable Computations in parallel .","title":"liftA2(f, ccA , ccB)"},{"location":"cancelable-api/#lifta3f-cca-ccb-ccc","text":":: (a \u2192 b \u2192 c \u2192 d) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c \u2192 Cancelable d","title":"liftA3(f, ccA , ccB, ccC)"},{"location":"cancelable-api/#lifta4f-cca-ccb-ccc-ccd","text":":: (a \u2192 b \u2192 c \u2192 d \u2192 e) \u2192 Cancelable a \u2192 Cancelable b \u2192 Cancelable c \u2192 Cancelable d \u2192 Cancelable e","title":"liftA4(f, ccA , ccB, ccC, ccD)"},{"location":"cancelable-api/#racecancelablea-cancelableb","text":":: Cancelable a \u2192 Cancelable a \u2192 Cancelable a Like Promise.race shortcuts (i.e. aborts the other) when any input value is settled with success or failure.","title":"race(cancelableA, cancelableB)"},{"location":"cancelable-api/#utility","text":"","title":"Utility"},{"location":"cancelable-api/#sharecancelable","text":":: Cancelable e a \u2192 Cancelable e a Caches the computational result for sharing with many consumers without the need for re-computation. See the section on Copying/Sharing Cancelables and it's role model Fluture.cache .","title":"share(cancelable)"},{"location":"cancelable/","text":"Cancelable Cancelable Computation A Cancelable Computation is a function which performs a cancelable asynchronous computation. CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) In general Cancelable Computations serves the same purpose as a Promises. Contrary to Promises, Cancelable Computations are lazily executed, have no internal mutating state - thus are referentially transparent, and cancellation is not propagated to the consumer. Executing Work The computation is started when the Cancelable Computation function is called - laziness . // Pseudocode let cancelableWork = (res, rej) => { beginSomeLongWork() whenLongWorkDone with result invoke res(result) whenLongWorkFailed with error invoke rej(error) return () => { // abort the work }; }; Propagating the Outcome The result or failing of the computation (aka settlement) is communicated via the two callback arguments (\"continuations\") in the same way as the computation function in a Promise constructor . Differently however, the settlement of the computation should not be communicated synchronously - enforced asynchronicity let ccFoo = (res, rej) => { res(\"foo\"); // BAD CODE! Do not invoke the callbacks synchronously! return () => undefined; }; let ccBar = (res, rej) => { const timer = setTimeout(res, 0, \"bar\"); // Always invoke the callbacks asynchronously! return () => { clearTimeout(timer); }; }; Such computation functions are the standard pattern in other libraries to create asynchronous tasks, e.g. creating Fluture Futures or Async in Crocks . In those other libraries however, the order of arguments differs from that of the Promise constructor; The rejection continuation comes before the success continuation. Consuming and Running Cancelables Simply use the Promise constructor to create a Promise from the Cancelable new Promise(cancelableComputation) . Note that if the computation is cancelled such a \"consumption\" Promise will never settle. See the section titled Cancellation Discontinues . Invoke the Cancelable and provide two callbacks as arguments toCancel = cancelableComputation(onSuccess, onFailure) Cancellation The Cancelable Computation Function returns a function to abort/ cancel the computation. A Cancelable Computation can be aborted by calling the abort function which is returned when the execution of the Cancelable Computation is started by invoking it with two callbacks. Thus, the computation cannot be canceled before it is started. let abort = cancelableComputation(onSuccess, onFailure); abort(); // Abort immediately. onSuccess and onFailure are never called When a Cancelable Computation aborts, the implementation must assert that neither the success, nor the failure callback are called. This is another difference to many cancelable computations represented by Promises. For example, aborting a fetch computation is known to reject the resulting promise with AbortError . Thus, a Cancelable fetch Computation should guarantee that the AbortError rejection does not reach the onFailure callback. When Cancelables are sequentially chained together by composing Cancelable-returning functions e.g. via chain , the cancellation travels the chain up, cancelling the computation which is active in the moment of calling abort() . Generators of Cancelable Computations The parameters of the asynchronous computation are given to a Cancelable Computation Generator Function which returns a Cancelable Computation configured to that parameters. This way the configuration of the computation is separated from its execution ( laziness ). The typical example in many similar libraries is that of a timer: // laterResolve :: (Number, t) -> CancelableComputation * t const laterResolve = (dt, value) => resolve => { const timer = setTimeout(resolve, dt, value); return () => { clearTimeout(timer); }; }; Rationale No Synchronicity The reason that a Cancelable Computation cannot synchronously invoke the callbacks with the outcome of the computation, is that otherwise certain combinators were not possible to implement. E.g. mutual cancellation of two simultaneously running computations in race would be much harder to implement. Cancellation Discontinues The two continuation callbacks are to collect the result of the successful computation and any computational error or exceptional path of execution. Aborting/Cancelling the computation by the consumer is not considered to be any of those two purposes. Since the calling code is (obviously) aware of the cancellation it can perform steps to publish that cancellation. The current cancellation behaviour could be extended be supporting asynchronous cancellation - i.e. the cancel function returning a Promise instead of void. However, cancelling the cancellation itself seems to be much of an overkill. Copying/Sharing A benefit of Native Promises is that they can be freely copied and shared in a program. Being eager they rather represent the eventual outcome of a computation than the computation itself. Thus copying makes much sense. However, the internal state of a Promise is time-dependent and thus opaque, i.e. not referentially transparent to the calling code. Depending on when probed by the surrounding code, Promises behave differently; E.g. a Promise.race will take a different route when one of its inputs is already settled. Being just referentially transparent functions, such opaque Promise behaviour is not possible with copies of Cancelable Computations. Everytime the same Cancelable get consumed the asynchronous computation is started anew, and the outcome and temporal behaviour will always be the same. Nevertheless \u2014 sharing/multicasting asynchronous computations being valuable \u2014 there are at least two ways making Cancelables shareable while maintaining the asynchronous character: convert to Promise new Promise(cancelableComputation) but thereby loosing cancelability, or caching/making them stateful with share share picks up many disadvantages of Promise but keeps the benefit of being able to get cancelled when all consumers decide to do so. let ccs = share(later(10, \"X\")); ccs(console.log, console.log); // ~> \"X\" (logged after 10) // \u2026 ccs(console.log, console.log); // ~> \"X\" (logged already on next tick!) Cancelling a shared Cancelable Computation merely means unsubscribing the continuation callbacks. It should be done when the code has lost interest in the outcome of the computation. The shared computation will continue to run if there are still any subscribers which have not cancelled. Otherwise, the internal state is reset, so that the computation will be recommenced on the next call. This way the internal state might toggle between \"initial\" and \"pending\" several times. Once allowed completing, the Shared Cancelable will simply yield the internally stored outcome to the caller.","title":"About Cancelables"},{"location":"cancelable/#cancelable","text":"","title":"Cancelable"},{"location":"cancelable/#cancelable-computation","text":"A Cancelable Computation is a function which performs a cancelable asynchronous computation. CancelableComputation e a :: ((a -> void), (e -> void)) -> (() -> void) In general Cancelable Computations serves the same purpose as a Promises. Contrary to Promises, Cancelable Computations are lazily executed, have no internal mutating state - thus are referentially transparent, and cancellation is not propagated to the consumer.","title":"Cancelable Computation"},{"location":"cancelable/#executing-work","text":"The computation is started when the Cancelable Computation function is called - laziness . // Pseudocode let cancelableWork = (res, rej) => { beginSomeLongWork() whenLongWorkDone with result invoke res(result) whenLongWorkFailed with error invoke rej(error) return () => { // abort the work }; };","title":"Executing Work"},{"location":"cancelable/#propagating-the-outcome","text":"The result or failing of the computation (aka settlement) is communicated via the two callback arguments (\"continuations\") in the same way as the computation function in a Promise constructor . Differently however, the settlement of the computation should not be communicated synchronously - enforced asynchronicity let ccFoo = (res, rej) => { res(\"foo\"); // BAD CODE! Do not invoke the callbacks synchronously! return () => undefined; }; let ccBar = (res, rej) => { const timer = setTimeout(res, 0, \"bar\"); // Always invoke the callbacks asynchronously! return () => { clearTimeout(timer); }; }; Such computation functions are the standard pattern in other libraries to create asynchronous tasks, e.g. creating Fluture Futures or Async in Crocks . In those other libraries however, the order of arguments differs from that of the Promise constructor; The rejection continuation comes before the success continuation.","title":"Propagating the Outcome"},{"location":"cancelable/#consuming-and-running-cancelables","text":"Simply use the Promise constructor to create a Promise from the Cancelable new Promise(cancelableComputation) . Note that if the computation is cancelled such a \"consumption\" Promise will never settle. See the section titled Cancellation Discontinues . Invoke the Cancelable and provide two callbacks as arguments toCancel = cancelableComputation(onSuccess, onFailure)","title":"Consuming and Running Cancelables"},{"location":"cancelable/#cancellation","text":"The Cancelable Computation Function returns a function to abort/ cancel the computation. A Cancelable Computation can be aborted by calling the abort function which is returned when the execution of the Cancelable Computation is started by invoking it with two callbacks. Thus, the computation cannot be canceled before it is started. let abort = cancelableComputation(onSuccess, onFailure); abort(); // Abort immediately. onSuccess and onFailure are never called When a Cancelable Computation aborts, the implementation must assert that neither the success, nor the failure callback are called. This is another difference to many cancelable computations represented by Promises. For example, aborting a fetch computation is known to reject the resulting promise with AbortError . Thus, a Cancelable fetch Computation should guarantee that the AbortError rejection does not reach the onFailure callback. When Cancelables are sequentially chained together by composing Cancelable-returning functions e.g. via chain , the cancellation travels the chain up, cancelling the computation which is active in the moment of calling abort() .","title":"Cancellation"},{"location":"cancelable/#generators-of-cancelable-computations","text":"The parameters of the asynchronous computation are given to a Cancelable Computation Generator Function which returns a Cancelable Computation configured to that parameters. This way the configuration of the computation is separated from its execution ( laziness ). The typical example in many similar libraries is that of a timer: // laterResolve :: (Number, t) -> CancelableComputation * t const laterResolve = (dt, value) => resolve => { const timer = setTimeout(resolve, dt, value); return () => { clearTimeout(timer); }; };","title":"Generators of Cancelable Computations"},{"location":"cancelable/#rationale","text":"","title":"Rationale"},{"location":"cancelable/#no-synchronicity","text":"The reason that a Cancelable Computation cannot synchronously invoke the callbacks with the outcome of the computation, is that otherwise certain combinators were not possible to implement. E.g. mutual cancellation of two simultaneously running computations in race would be much harder to implement.","title":"No Synchronicity"},{"location":"cancelable/#cancellation-discontinues","text":"The two continuation callbacks are to collect the result of the successful computation and any computational error or exceptional path of execution. Aborting/Cancelling the computation by the consumer is not considered to be any of those two purposes. Since the calling code is (obviously) aware of the cancellation it can perform steps to publish that cancellation. The current cancellation behaviour could be extended be supporting asynchronous cancellation - i.e. the cancel function returning a Promise instead of void. However, cancelling the cancellation itself seems to be much of an overkill.","title":"Cancellation Discontinues"},{"location":"cancelable/#copyingsharing","text":"A benefit of Native Promises is that they can be freely copied and shared in a program. Being eager they rather represent the eventual outcome of a computation than the computation itself. Thus copying makes much sense. However, the internal state of a Promise is time-dependent and thus opaque, i.e. not referentially transparent to the calling code. Depending on when probed by the surrounding code, Promises behave differently; E.g. a Promise.race will take a different route when one of its inputs is already settled. Being just referentially transparent functions, such opaque Promise behaviour is not possible with copies of Cancelable Computations. Everytime the same Cancelable get consumed the asynchronous computation is started anew, and the outcome and temporal behaviour will always be the same. Nevertheless \u2014 sharing/multicasting asynchronous computations being valuable \u2014 there are at least two ways making Cancelables shareable while maintaining the asynchronous character: convert to Promise new Promise(cancelableComputation) but thereby loosing cancelability, or caching/making them stateful with share share picks up many disadvantages of Promise but keeps the benefit of being able to get cancelled when all consumers decide to do so. let ccs = share(later(10, \"X\")); ccs(console.log, console.log); // ~> \"X\" (logged after 10) // \u2026 ccs(console.log, console.log); // ~> \"X\" (logged already on next tick!) Cancelling a shared Cancelable Computation merely means unsubscribing the continuation callbacks. It should be done when the code has lost interest in the outcome of the computation. The shared computation will continue to run if there are still any subscribers which have not cancelled. Otherwise, the internal state is reset, so that the computation will be recommenced on the next call. This way the internal state might toggle between \"initial\" and \"pending\" several times. Once allowed completing, the Shared Cancelable will simply yield the internally stored outcome to the caller.","title":"Copying/Sharing"},{"location":"changelog/","text":"Changelog v0.2.0 0.2.0 point-free functions chain , map , ap , liftA2 to support FantasyLand types and native Promise Fantasy-Land support for Cancelables 0.1.43 maybe/pluck 0.1.42 Maybe and Either are now \"opaque\" TS types. 0.1.40 cancelable/liftA3 , cancelable/liftA4 0.1.39 cancelable/pluck 0.1.38 adds: either/traverse , either/sequence 0.1.37 chore: replaced semmel-ramda v0.33.0 with ramda v0.28.0 0.1.36 fix: cancelable/ap and thus cancelable/liftA2 did always resolve the right argument with undefined . 0.1.35 fix: transformations/cancelableToEventStream avoid cancellation for synchronous calls (e.g. when the stream ends thus calling abort synchronously on behalf of sink(x) 0.1.34 fix: transformations/cancelableToEventStream no longer invokes the Cancelable's abort function if the event stream ends after the Cancelable has settled. 0.1.33 exceptions in the cancelable/bi_tap functions get picked up 0.1.32 added cancelable/share 0.1.31 migrate cancelable/fetchResponse(NodeJS) to cancelable/fetchResponseIsoModule(globalThis) 0.1.30 forgot either/isEither to export 0.1.29 adds cancelable/cancelify 0.1.28 test: eitherToPromise 0.1.27 lenses Breaking: removed unlens , propUnlens , indexUnlens 0.1.26 unlens, propUnlens, indexUnlens 0.1.25 duplexRace for Promise 0.1.24 find_l 0.1.23 bi_tap 0.1.22 updated rollup plugin 0.1.21 added sequence and traverse for Arrays (\"Lists\") added sequence and traverse for Maybe 0.1.20 added maybeOfCancelableToCancelableOfMaybe moved to JSON license generate HTML doc and publish on GitHub pages 0.1.19 added maybeOfBaconObservableToBaconObservableOfMaybe 0.1.16 Begun API for CancelableComputation incl. natural transformations to and from Bacon and Most streams 0.1.15 fix: Either no longer based on a unique Symbol but rather on a unique string. This should make Either compatible with a differently loaded staticland library. 0.1.11 more submodules for Node.js consumption 0.1.4 Adds transformation maybeOfPromiseToPromiseOfMaybe 0.1.2 Added transformations 0.1.1 Added Either type Added transformations fo Either and Maybe to Promise","title":"Changelog"},{"location":"changelog/#changelog-v020","text":"","title":"Changelog v0.2.0"},{"location":"changelog/#020","text":"point-free functions chain , map , ap , liftA2 to support FantasyLand types and native Promise Fantasy-Land support for Cancelables","title":"0.2.0"},{"location":"changelog/#0143","text":"maybe/pluck","title":"0.1.43"},{"location":"changelog/#0142","text":"Maybe and Either are now \"opaque\" TS types.","title":"0.1.42"},{"location":"changelog/#0140","text":"cancelable/liftA3 , cancelable/liftA4","title":"0.1.40"},{"location":"changelog/#0139","text":"cancelable/pluck","title":"0.1.39"},{"location":"changelog/#0138","text":"adds: either/traverse , either/sequence","title":"0.1.38"},{"location":"changelog/#0137","text":"chore: replaced semmel-ramda v0.33.0 with ramda v0.28.0","title":"0.1.37"},{"location":"changelog/#0136","text":"fix: cancelable/ap and thus cancelable/liftA2 did always resolve the right argument with undefined .","title":"0.1.36"},{"location":"changelog/#0135","text":"fix: transformations/cancelableToEventStream avoid cancellation for synchronous calls (e.g. when the stream ends thus calling abort synchronously on behalf of sink(x)","title":"0.1.35"},{"location":"changelog/#0134","text":"fix: transformations/cancelableToEventStream no longer invokes the Cancelable's abort function if the event stream ends after the Cancelable has settled.","title":"0.1.34"},{"location":"changelog/#0133","text":"exceptions in the cancelable/bi_tap functions get picked up","title":"0.1.33"},{"location":"changelog/#0132","text":"added cancelable/share","title":"0.1.32"},{"location":"changelog/#0131","text":"migrate cancelable/fetchResponse(NodeJS) to cancelable/fetchResponseIsoModule(globalThis)","title":"0.1.31"},{"location":"changelog/#0130","text":"forgot either/isEither to export","title":"0.1.30"},{"location":"changelog/#0129","text":"adds cancelable/cancelify","title":"0.1.29"},{"location":"changelog/#0128","text":"test: eitherToPromise","title":"0.1.28"},{"location":"changelog/#0127","text":"lenses Breaking: removed unlens , propUnlens , indexUnlens","title":"0.1.27"},{"location":"changelog/#0126","text":"unlens, propUnlens, indexUnlens","title":"0.1.26"},{"location":"changelog/#0125","text":"duplexRace for Promise","title":"0.1.25"},{"location":"changelog/#0124","text":"find_l","title":"0.1.24"},{"location":"changelog/#0123","text":"bi_tap","title":"0.1.23"},{"location":"changelog/#0122","text":"updated rollup plugin","title":"0.1.22"},{"location":"changelog/#0121","text":"added sequence and traverse for Arrays (\"Lists\") added sequence and traverse for Maybe","title":"0.1.21"},{"location":"changelog/#0120","text":"added maybeOfCancelableToCancelableOfMaybe moved to JSON license generate HTML doc and publish on GitHub pages","title":"0.1.20"},{"location":"changelog/#0119","text":"added maybeOfBaconObservableToBaconObservableOfMaybe","title":"0.1.19"},{"location":"changelog/#0116","text":"Begun API for CancelableComputation incl. natural transformations to and from Bacon and Most streams","title":"0.1.16"},{"location":"changelog/#0115","text":"fix: Either no longer based on a unique Symbol but rather on a unique string. This should make Either compatible with a differently loaded staticland library.","title":"0.1.15"},{"location":"changelog/#0111","text":"more submodules for Node.js consumption","title":"0.1.11"},{"location":"changelog/#014","text":"Adds transformation maybeOfPromiseToPromiseOfMaybe","title":"0.1.4"},{"location":"changelog/#012","text":"Added transformations","title":"0.1.2"},{"location":"changelog/#011","text":"Added Either type Added transformations fo Either and Maybe to Promise","title":"0.1.1"},{"location":"either/","text":"Either represents two mutually exclusive values, e.g. instead of throwing, a computation could return a computed result or a computational error in an Either. As by convention the generally anticipated outcome is stored as a right , while the exceptional value is a left . Generators right(a) :: a -> Either * a left(c) :: c -> Either c * fromThrowable(fn)(...args) :: (\u2026b -> a) -> \u2026b -> Either c a fromAssertedValue(predicate, makeLeftValue, a) :: (a -> Boolean) -> (a -> c) -> a -> Either c a Inspection isRight(m) :: Either c a -> Boolean isLeft(m) :: Either c a -> Boolean isEither(m) :: Either c a -> Boolean Transformation chain(fn, ma) :: Either m \u21d2 (a \u2192 m e b) \u2192 m c a \u2192 m e b Useful for converting a right to a left. chainLeft(fn, ma) :: Either m \u21d2 (c \u2192 m e b) \u2192 m c a \u2192 m e b Useful for converting a left to a right. map(fn, ma) :: (a -> b) -> Either c a -> Either c b sequence(of_f, map_f, EitherOfF) :: Applicative f => ((a \u2192 f a), ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 Either c (f a) \u2192 f (Either c a) Swap the sequence of types: Maybe of Functor of Value to Functor of Maybe of Value. Maybe takes the role of a \"Traversable\" t . traverse(of_f, map_f, effect_to_f, either) :: (Applicative f, Traversable t) => (c \u2192 f c) \u2192 ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 (a \u2192 f b) \u2192 Either c a \u2192 f (Either c b) Applies an \"effect\" effect_to_f to the value inside the Maybe. Then combines that \"effect\" with the Maybe by wrapping the \"effect's\" result in an Applicative of a Maybe. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a Promise of a Maybe than a Maybe of a Promise. Using traverse essentially combines mapping the effect_to_f over the Maybe and calling sequence(of_f, map_f) in a single step. Consumption either(onLeftVal, onRightVal, m) :: (c -> b) -> (a -> b) -> Either c a -> b","title":"Either"},{"location":"either/#either","text":"represents two mutually exclusive values, e.g. instead of throwing, a computation could return a computed result or a computational error in an Either. As by convention the generally anticipated outcome is stored as a right , while the exceptional value is a left .","title":"Either"},{"location":"either/#generators","text":"","title":"Generators"},{"location":"either/#righta","text":":: a -> Either * a","title":"right(a)"},{"location":"either/#leftc","text":":: c -> Either c *","title":"left(c)"},{"location":"either/#fromthrowablefnargs","text":":: (\u2026b -> a) -> \u2026b -> Either c a","title":"fromThrowable(fn)(...args)"},{"location":"either/#fromassertedvaluepredicate-makeleftvalue-a","text":":: (a -> Boolean) -> (a -> c) -> a -> Either c a","title":"fromAssertedValue(predicate, makeLeftValue, a)"},{"location":"either/#inspection","text":"","title":"Inspection"},{"location":"either/#isrightm","text":":: Either c a -> Boolean","title":"isRight(m)"},{"location":"either/#isleftm","text":":: Either c a -> Boolean","title":"isLeft(m)"},{"location":"either/#iseitherm","text":":: Either c a -> Boolean","title":"isEither(m)"},{"location":"either/#transformation","text":"","title":"Transformation"},{"location":"either/#chainfn-ma","text":":: Either m \u21d2 (a \u2192 m e b) \u2192 m c a \u2192 m e b Useful for converting a right to a left.","title":"chain(fn, ma)"},{"location":"either/#chainleftfn-ma","text":":: Either m \u21d2 (c \u2192 m e b) \u2192 m c a \u2192 m e b Useful for converting a left to a right.","title":"chainLeft(fn, ma)"},{"location":"either/#mapfn-ma","text":":: (a -> b) -> Either c a -> Either c b","title":"map(fn, ma)"},{"location":"either/#sequenceof_f-map_f-eitheroff","text":":: Applicative f => ((a \u2192 f a), ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 Either c (f a) \u2192 f (Either c a) Swap the sequence of types: Maybe of Functor of Value to Functor of Maybe of Value. Maybe takes the role of a \"Traversable\" t .","title":"sequence(of_f, map_f, EitherOfF)"},{"location":"either/#traverseof_f-map_f-effect_to_f-either","text":":: (Applicative f, Traversable t) => (c \u2192 f c) \u2192 ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 (a \u2192 f b) \u2192 Either c a \u2192 f (Either c b) Applies an \"effect\" effect_to_f to the value inside the Maybe. Then combines that \"effect\" with the Maybe by wrapping the \"effect's\" result in an Applicative of a Maybe. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a Promise of a Maybe than a Maybe of a Promise. Using traverse essentially combines mapping the effect_to_f over the Maybe and calling sequence(of_f, map_f) in a single step.","title":"traverse(of_f, map_f, effect_to_f, either)"},{"location":"either/#consumption","text":"","title":"Consumption"},{"location":"either/#eitheronleftval-onrightval-m","text":":: (c -> b) -> (a -> b) -> Either c a -> b","title":"either(onLeftVal, onRightVal, m)"},{"location":"function/","text":"Function Functions x \u2192 b can be treated as functors (\u2192 x) b (or Functor f \u21d2 f b ). The functor f or (\u2192 x) represents all functions accepting x as argument. For an introduction into that concept, explanations and examples see the article from Tom Harding . Reader Treating functions as functors for instance makes it possible to compose pipelines of functions which are applied sequentially to their respective return values \u2013 as usual \u2013 but which are only executed when called with an additional, possibly mutable, argument \u2013 usually called \"environment\". Invoked with just their \"primary\" pipeline-entry argument, the pipeline is not executed and is thus referentially transparent. The responsibility to permit reading from the environment is left for the final caller of this so-called Reader . This is much like a binary curried function a => b => someOperation(a, b) which happens to be the of factory for Reader of = x => env => x . map map :: Functor f \u21d2 (b \u2192 c) \u2192 f b \u2192 f c map :: (b \u2192 c) \u2192 (\u2192 a) b \u2192 (\u2192 a) c map :: (b \u2192 c) \u2192 (a \u2192 b) \u2192 (a \u2192 c) simply compose, really. not implemented \u2013 use Ramda.map Using Ramda The Ramda version of the ADT functions ap , map and chain support not only StaticLand (i.e. native JavaScript) List functors (that is: Array ) but also function functors. Some function combinators \u2013 which are useful for programming in point-free style \u2013 can be implemented with help of the ADT functions:","title":"Function"},{"location":"function/#function","text":"Functions x \u2192 b can be treated as functors (\u2192 x) b (or Functor f \u21d2 f b ). The functor f or (\u2192 x) represents all functions accepting x as argument. For an introduction into that concept, explanations and examples see the article from Tom Harding .","title":"Function"},{"location":"function/#reader","text":"Treating functions as functors for instance makes it possible to compose pipelines of functions which are applied sequentially to their respective return values \u2013 as usual \u2013 but which are only executed when called with an additional, possibly mutable, argument \u2013 usually called \"environment\". Invoked with just their \"primary\" pipeline-entry argument, the pipeline is not executed and is thus referentially transparent. The responsibility to permit reading from the environment is left for the final caller of this so-called Reader . This is much like a binary curried function a => b => someOperation(a, b) which happens to be the of factory for Reader of = x => env => x .","title":"Reader"},{"location":"function/#map","text":"map :: Functor f \u21d2 (b \u2192 c) \u2192 f b \u2192 f c map :: (b \u2192 c) \u2192 (\u2192 a) b \u2192 (\u2192 a) c map :: (b \u2192 c) \u2192 (a \u2192 b) \u2192 (a \u2192 c) simply compose, really. not implemented \u2013 use Ramda.map","title":"map"},{"location":"function/#using-ramda","text":"The Ramda version of the ADT functions ap , map and chain support not only StaticLand (i.e. native JavaScript) List functors (that is: Array ) but also function functors. Some function combinators \u2013 which are useful for programming in point-free style \u2013 can be implemented with help of the ADT functions:","title":"Using Ramda"},{"location":"io/","text":"IO import {tap, o, pipe} from 'ramda'; var beautifyCpuOut = map(t => `${(t / 1.0e+6).toExponential()} sec`), cpu = of(process.cpuUsage), getDeltaCpu = previous => of(() => process.cpuUsage(previous)); pipe( () => cpu, map(tap(o(console.log, beautifyCpuOut))), chain(cpuOut => getDeltaCpu(cpuOut)), map(beautifyCpuOut), run )(); // -> { user: '4.923326e+0 sec', system: '1.297826e+0 sec' } // -> { user: '2.34e-4 sec', system: '2.1e-5 sec' }","title":"Io"},{"location":"io/#io","text":"import {tap, o, pipe} from 'ramda'; var beautifyCpuOut = map(t => `${(t / 1.0e+6).toExponential()} sec`), cpu = of(process.cpuUsage), getDeltaCpu = previous => of(() => process.cpuUsage(previous)); pipe( () => cpu, map(tap(o(console.log, beautifyCpuOut))), chain(cpuOut => getDeltaCpu(cpuOut)), map(beautifyCpuOut), run )(); // -> { user: '4.923326e+0 sec', system: '1.297826e+0 sec' } // -> { user: '2.34e-4 sec', system: '2.1e-5 sec' }","title":"IO"},{"location":"lens/","text":"Lens A Lens is a function which focuses on a particular aspect, property, index, ... of a data structure. Their purpose is to make changes in a data structure in a non-mutating functional way. Lenses compose with themselves, traversal functions ( Type.traverse(of_f, liftA2_f) ), mapping functions ( Type.map ) and isomorphism functions. All these items piped together drill deep down into a data structure. Thereby a particular aspect deep in this complex data structure can be modeled by such a composed lens function. Lenses are put into action by a set of helper functions ( view , over , set ) which take the lens and source data as arguments and return the result data. For a thorough introduction read \"Lenses with Immutable.js\" by Brian Lonsdorf , for the details of the implementation for StaticLand data structures read \"Partial Lenses Implementation\" by Vesa Karvonen Types MapF = Functor F => (a -> b) -> Fa -> Fb Lens sa = MapF => MapF -> (a -> Fa) -> sa -> Fsa ComposableLens sa = (a -> Fa) -> sa -> Fsa Note that ComposableLens bears the same signature as traverse(of_f, map_f) and map . Static-Land vs. Fantasy-Land (Ramda) Lenses A lens is primary implemented as lens = getter, setter => Fmap => x2Fy => xs => Fmap(y => setter(y, xs), x2Fy(getter(xs))); While in Fantasy-Land the Fmap argument is not needed, since the functor's map function is referenced by the [fantasy-land/map] property. lens = getter, setter => x2Fy => xs => x2Fy(getter(xs))[fantasy-land/map](y => setter(y, xs)); Thus, in StaticLand composability requires specifying a particular functor's map and therefore is much more laborious or requires a layer of helper functions. Creation In general two procedures are required, one for extracting the item of interest, the other for re-assembling the data structure. The returned functions (i.e. lenses) themselves cannot be composed together. Instead, they serve as initial building blocks for the entire composition of the data aspect. lens(getter, setter) :: (sa -> a) -> ((a, sa) -> sa) -> Lens sa Compare lens to promap : const charLens = lens(s => s.charCodeAt(0), n => String.fromCharCode(n)), stringLens = lens(R.split(''), R.join('')), charLensC = makeComposableOverLens(charLens), stringLensC = makeComposableOverLens(stringLens), singleLens = R.compose(stringLensC, R.unary(R.map), charLensC); over(singleLens, R.add(-8), \"ziuli\"); // -> 'ramda' // promap example from the Ramda documentation: const decodeChar = R.promap(s => s.charCodeAt(), n => String.fromCharCode(n), R.add(-8)), decodeString = R.promap(R.split(''), R.join(''), R.map(decodeChar)); decodeString(\"ziuli\") //=> \"ramda\" indexLens(n) :: Number -> Lens sa propertyLens(key) Create Composable Lenses These can be composed with map , traverse and themselves to define the focus on the data aspect. makeComposableViewLens(lens) F \u2261 Constant Creates one map -like function for viewing / extracting a data aspect. makeComposableOverLens(lens) F \u2261 Identity Example, the data is inside a bar property inside a Promise // data aspect // \u2193 const data = { bar: Promise.resolve(\"BAR\") }, barLens = propertyLens(\"bar\"), // decide to \"mutate the data structure, so make an OverLens: composableBarLens = makeComposableOverLens(barLens), // define the whole path to the data aspect = compose(composableBarLens, mapPromise); // employ in a functional pipeline changeAspect = over(aspect); changeAspect(reverse)(data); // { bar: Promise.resolve(\"RAB\") } makeComposableSequenceLens(map_f, lens) F \u2261 f Employ Lenses view(viewLens) :: Lens sa -> a over(overLens) :: Lens sa -> (a -> a) -> sa -> sa set(overLens) :: Lens sa -> a -> sa -> sa sequence(lens, subject) :: ComposableLens sa -> saf -> fsa Turn an array with a Maybe element at second place into a Maybe of an array. const focusL = indexLens(1), subjectA = [\"foo\", just(\"bar\")], subjectB = [\"foo\", nothing()]; sequence(focusL(Maybe.map), subjectA) // -> just([\"foo\", \"bar\"]) sequence(focusL(Maybe.map), subjectB) // -> nothing","title":"Lens"},{"location":"lens/#lens","text":"A Lens is a function which focuses on a particular aspect, property, index, ... of a data structure. Their purpose is to make changes in a data structure in a non-mutating functional way. Lenses compose with themselves, traversal functions ( Type.traverse(of_f, liftA2_f) ), mapping functions ( Type.map ) and isomorphism functions. All these items piped together drill deep down into a data structure. Thereby a particular aspect deep in this complex data structure can be modeled by such a composed lens function. Lenses are put into action by a set of helper functions ( view , over , set ) which take the lens and source data as arguments and return the result data. For a thorough introduction read \"Lenses with Immutable.js\" by Brian Lonsdorf , for the details of the implementation for StaticLand data structures read \"Partial Lenses Implementation\" by Vesa Karvonen","title":"Lens"},{"location":"lens/#types","text":"MapF = Functor F => (a -> b) -> Fa -> Fb Lens sa = MapF => MapF -> (a -> Fa) -> sa -> Fsa ComposableLens sa = (a -> Fa) -> sa -> Fsa Note that ComposableLens bears the same signature as traverse(of_f, map_f) and map .","title":"Types"},{"location":"lens/#static-land-vs-fantasy-land-ramda-lenses","text":"A lens is primary implemented as lens = getter, setter => Fmap => x2Fy => xs => Fmap(y => setter(y, xs), x2Fy(getter(xs))); While in Fantasy-Land the Fmap argument is not needed, since the functor's map function is referenced by the [fantasy-land/map] property. lens = getter, setter => x2Fy => xs => x2Fy(getter(xs))[fantasy-land/map](y => setter(y, xs)); Thus, in StaticLand composability requires specifying a particular functor's map and therefore is much more laborious or requires a layer of helper functions.","title":"Static-Land vs. Fantasy-Land (Ramda) Lenses"},{"location":"lens/#creation","text":"In general two procedures are required, one for extracting the item of interest, the other for re-assembling the data structure. The returned functions (i.e. lenses) themselves cannot be composed together. Instead, they serve as initial building blocks for the entire composition of the data aspect.","title":"Creation"},{"location":"lens/#lensgetter-setter","text":":: (sa -> a) -> ((a, sa) -> sa) -> Lens sa Compare lens to promap : const charLens = lens(s => s.charCodeAt(0), n => String.fromCharCode(n)), stringLens = lens(R.split(''), R.join('')), charLensC = makeComposableOverLens(charLens), stringLensC = makeComposableOverLens(stringLens), singleLens = R.compose(stringLensC, R.unary(R.map), charLensC); over(singleLens, R.add(-8), \"ziuli\"); // -> 'ramda' // promap example from the Ramda documentation: const decodeChar = R.promap(s => s.charCodeAt(), n => String.fromCharCode(n), R.add(-8)), decodeString = R.promap(R.split(''), R.join(''), R.map(decodeChar)); decodeString(\"ziuli\") //=> \"ramda\"","title":"lens(getter, setter)"},{"location":"lens/#indexlensn","text":":: Number -> Lens sa","title":"indexLens(n)"},{"location":"lens/#propertylenskey","text":"","title":"propertyLens(key)"},{"location":"lens/#create-composable-lenses","text":"These can be composed with map , traverse and themselves to define the focus on the data aspect.","title":"Create Composable Lenses"},{"location":"lens/#makecomposableviewlenslens","text":"F \u2261 Constant Creates one map -like function for viewing / extracting a data aspect.","title":"makeComposableViewLens(lens)"},{"location":"lens/#makecomposableoverlenslens","text":"F \u2261 Identity Example, the data is inside a bar property inside a Promise // data aspect // \u2193 const data = { bar: Promise.resolve(\"BAR\") }, barLens = propertyLens(\"bar\"), // decide to \"mutate the data structure, so make an OverLens: composableBarLens = makeComposableOverLens(barLens), // define the whole path to the data aspect = compose(composableBarLens, mapPromise); // employ in a functional pipeline changeAspect = over(aspect); changeAspect(reverse)(data); // { bar: Promise.resolve(\"RAB\") }","title":"makeComposableOverLens(lens)"},{"location":"lens/#makecomposablesequencelensmap_f-lens","text":"F \u2261 f","title":"makeComposableSequenceLens(map_f, lens)"},{"location":"lens/#employ-lenses","text":"","title":"Employ Lenses"},{"location":"lens/#viewviewlens","text":":: Lens sa -> a","title":"view(viewLens)"},{"location":"lens/#overoverlens","text":":: Lens sa -> (a -> a) -> sa -> sa","title":"over(overLens)"},{"location":"lens/#setoverlens","text":":: Lens sa -> a -> sa -> sa","title":"set(overLens)"},{"location":"lens/#sequencelens-subject","text":":: ComposableLens sa -> saf -> fsa Turn an array with a Maybe element at second place into a Maybe of an array. const focusL = indexLens(1), subjectA = [\"foo\", just(\"bar\")], subjectB = [\"foo\", nothing()]; sequence(focusL(Maybe.map), subjectA) // -> just([\"foo\", \"bar\"]) sequence(focusL(Maybe.map), subjectB) // -> nothing","title":"sequence(lens, subject)"},{"location":"license/","text":"The JSON License (JSON) Copyright (c) 2020-2021 Matthias Seemann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software shall be used for Good, not Evil. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"list/","text":"List By List is a synonym for Array-like collections. Although at this stage, @visisoft/staticland/list supports just Array as list type. If combining just data or functions with a \"list\", these functions (like map , chain , of , etc.) are provided by Ramda and thus will not be implemented here. However, when combining \"list\" with other algebraic types, unfortunately Ramda expects them to be Fantasy-Land objects with accordingly named methods. So, because Static-Land is all about static functions instead of member functions, @visisoft/staticland/list provides the following functions that work with combinations of \"list\" with the other @visisoft/staticland data \"types\". Searching find(predicate, list) :: (a \u2192 Boolean) \u2192 [a] \u2192 Maybe a Transformation map(a2b) :: (a -> b) -> [a] -> [b] sequence(of_f, liftA2_f, arrayOfF) :: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 [f a] \u2192 f [a] Swap the sequence of both the types List and a Functor: Turns a List of Functors of Values into a Functor of a List of Values. Example import {liftA2 as liftA2_mb, of as of_mb, nothing, just} from '@visisoft/staticland/maybe'; const listOfMaybesToMaybeOfList = sequence(of_mb, liftA2_mb); listOfMaybesToMaybeOfList([just(\"me\"), just(\"you\")]); // -> Just([\"me\", \"you\"]) listOfMaybesToMaybeOfList([just(\"me\"), nothing()]); // -> Nothing Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions. traverse(of_f, liftA2_f, effect_to_f, array) :: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 (a \u2192 f b) \u2192 [a] \u2192 f [b] Applies an \"effect\" effect_to_f to the values of the List. Then combines that \"effect\" with the List by wrapping the \"effect's\" result in an Applicative of a List. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a single Promise of a List of the asynchronous computation results than a List of Promises of that results. Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions. Example const // :: (a -> Promise b) -> List a -> Promise List b traversePromiseFactoryInList = traverse_l(of_p, liftA2_p), // :: Number -> Promise Number asyncSquareRoot = x => (x >= 0) ? later_p(100, Math.sqrt(x)) : laterFail(25, \"complex result\"); traversePromiseFactoryInList(asyncSquareRoot, [4, 25, 81]) // -> Promise [2, 5, 9]","title":"List"},{"location":"list/#list","text":"By List is a synonym for Array-like collections. Although at this stage, @visisoft/staticland/list supports just Array as list type. If combining just data or functions with a \"list\", these functions (like map , chain , of , etc.) are provided by Ramda and thus will not be implemented here. However, when combining \"list\" with other algebraic types, unfortunately Ramda expects them to be Fantasy-Land objects with accordingly named methods. So, because Static-Land is all about static functions instead of member functions, @visisoft/staticland/list provides the following functions that work with combinations of \"list\" with the other @visisoft/staticland data \"types\".","title":"List"},{"location":"list/#searching","text":"","title":"Searching"},{"location":"list/#findpredicate-list","text":":: (a \u2192 Boolean) \u2192 [a] \u2192 Maybe a","title":"find(predicate, list)"},{"location":"list/#transformation","text":"","title":"Transformation"},{"location":"list/#mapa2b","text":":: (a -> b) -> [a] -> [b]","title":"map(a2b)"},{"location":"list/#sequenceof_f-lifta2_f-arrayoff","text":":: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 [f a] \u2192 f [a] Swap the sequence of both the types List and a Functor: Turns a List of Functors of Values into a Functor of a List of Values.","title":"sequence(of_f, liftA2_f, arrayOfF)"},{"location":"list/#example","text":"import {liftA2 as liftA2_mb, of as of_mb, nothing, just} from '@visisoft/staticland/maybe'; const listOfMaybesToMaybeOfList = sequence(of_mb, liftA2_mb); listOfMaybesToMaybeOfList([just(\"me\"), just(\"you\")]); // -> Just([\"me\", \"you\"]) listOfMaybesToMaybeOfList([just(\"me\"), nothing()]); // -> Nothing Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions.","title":"Example"},{"location":"list/#traverseof_f-lifta2_f-effect_to_f-array","text":":: Applicative f => ((a \u2192 f a), ((a \u2192 b \u2192 c) \u2192 f a \u2192 f b \u2192 f c) \u2192 (a \u2192 f b) \u2192 [a] \u2192 f [b] Applies an \"effect\" effect_to_f to the values of the List. Then combines that \"effect\" with the List by wrapping the \"effect's\" result in an Applicative of a List. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a single Promise of a List of the asynchronous computation results than a List of Promises of that results. Note that the first two parameters of_f and liftA2_f are just needed to support the implementation. Both should be taken from the Applicative f 's static functions.","title":"traverse(of_f, liftA2_f, effect_to_f, array)"},{"location":"list/#example_1","text":"const // :: (a -> Promise b) -> List a -> Promise List b traversePromiseFactoryInList = traverse_l(of_p, liftA2_p), // :: Number -> Promise Number asyncSquareRoot = x => (x >= 0) ? later_p(100, Math.sqrt(x)) : laterFail(25, \"complex result\"); traversePromiseFactoryInList(asyncSquareRoot, [4, 25, 81]) // -> Promise [2, 5, 9]","title":"Example"},{"location":"maybe/","text":"Maybe Working with optional data, commonly done with if - else blocks. Native JavaScript arrays which are empty or have a single element are considered a Maybe here. Generators fromNilable :: (a|undefined|null) \u2192 Maybe a Generates a maybe from a value which can be nullish. fromNilable({}.foo) // Nothing fromNilable(\"bar\") // Just(\"bar\") fromContentHolding(a) :: a \u2192 Maybe a fromContentHolding(\"a\") // Just(\"a\") fromContentHolding(\"\") // Nothing fromPredicate(predicate, subject) :: (a \u2192 Boolean) \u2192 a \u2192 Maybe a If the predicate test holds it returns the subject as a Just , otherwise a Nothing . Consumption getOrElse(defaultValue, m) :: a -> Maybe a -> a Extract the value of a Just or return the provided default. getOrElse(\"foo\", nothing()); // -> \"foo\" getOrElse(\"foo\", just(\"bar\")); // -> \"bar\" maybe(onNothing, doWithJust, m) :: (() -> b) -> (a -> b) -> Maybe a -> b Composition of getOrElse and map . Transforms the value if it exists with the provided function. Otherwise, returns the default value. Transformation pluck(key) :: Maybe m => k -> m {k: v} -> m v :: Maybe m => number -> m [v] -> m v Simply k => map(R.prop(k)) for mapping to a key value. sequence(of_f, map_f, MaybeOfF) :: Applicative f => ((a \u2192 f a), ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 Maybe (f a) \u2192 f (Maybe a) Swap the sequence of types: Maybe of Functor of Value to Functor of Maybe of Value. Maybe takes the role of a \"Traversable\" t . Examples Change a Maybe of a Promise into a Promise of a Maybe const // :: Maybe Promise e a -> Promise e Maybe a maybeOfPromiseToPromiseOfMaybe = sequence(of_p, map_p); maybeOfPromiseToPromiseOfMaybe(just(Promise.resolve(\"foo\"))); // -> Promise Just \"foo\" maybeOfPromiseToPromiseOfMaybe(just(Promise.reject(\"bar\"))); // -> Promise.reject(\"bar\") maybeOfPromiseToPromiseOfMaybe(nothing()); // -> Promise Nothing // getInputValue :: () -> Maybe string // fetchServer :: string -> Promise data // map_mb :: (a -> b) -> Maybe a -> Maybe b // defaultData :: data const // :: a -> Promise a of_p = value => Promise.resolve(value), // :: (a -> b) -> Promise a -> Promise b map_p = curry((fn, aPromise) => aPromise.then(fn)), // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String map_mb(fetchServer), // :: Maybe Promise Data maybeOfPromiseToPromiseOfMaybe, // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data ); Change a Maybe of a Key-Value Pair into a Key-Value Pair of a Maybe maybeOfFooObjectToObjectFooOfMaybe :: Maybe {foo: a} \u2192 {foo: Maybe a} import {modify, objOf} from 'ramda'; const ofFooObj = x => ({foo: x}), // :: a \u2192 {foo: a} mapFooObj = modify(\"foo\"), // :: (a \u2192 b) \u2192 {foo: a} \u2192 {foo: b} maybeOfFooObjectToObjectFooOfMaybe = // :: Maybe {foo: a} \u2192 {foo: Maybe a} sequence(ofFooObj, mapFooObj), justFooBar = just({foo: \"bar\"}); // :: Just {foo: \"bar\"} maybeOfFooObjectToObjectFooOfMaybe(justFooBar); // {foo: Maybe \"bar\"} traverse(of_f, map_f, effect_to_f, maybe) :: (Applicative f, Traversable t) => (c \u2192 f c) \u2192 ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 (a \u2192 f b) \u2192 Maybe a \u2192 f (Maybe b) Applies an \"effect\" effect_to_f to the value inside the Maybe. Then combines that \"effect\" with the Maybe by wrapping the \"effect's\" result in an Applicative of a Maybe. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a Promise of a Maybe than a Maybe of a Promise. Using traverse essentially combines mapping the effect_to_f over the Maybe and calling sequence(of_f, map_f) in a single step. // see first example for sequence const // :: (a \u2192 Promise b) \u2192 Maybe a \u2192 Promise Maybe b applyToPromiseOfMaybe = traverse(of_p, map_p), // :: a \u2192 Promise b delayEffect = x => new Promise(resolve => setTimeout(resolve, 1000, x)); applyToPromiseOfMaybe(delayEffect, just(\"foo\")); // -> Promise Just \"foo\" applyToPromiseOfMaybe(delayEffect, nothing()); // -> Promise Nothing // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String applyToPromiseOfMaybe(fetchServer), // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data ); Relation with sequence sequence(of_f, map_f, t) \u2261 traverse(of, map, identity, t) , and traverse(of_f, map_f, effect_to_f, t) \u2261 sequence(of_f, map_f, map(effect_to_f, t)) . The first two parameters of sequence and traverse are the same and due to the implementation. Caveats Argument type checking This library functions do not guard the user from supplying arguments of a wrong type. In particular, passing some other type as the maybe subject or passing a function to chain which returns a some other type, will cause undefined behaviour later. Value limitations Choosing empty and single-element arrays as implementation of the Maybe type causes these ambiguities: - A just and any single element array, - a nothing and any empty array cannot be distinguished. This directly affects the inspection functions isJust , isNothing and equals . E.g. equals(of(x), [x]) is true as well as equals(nothing(), []) is also true . Also join() will treat a just containing an empty array as a just containing nothing which is collapsed to a nothing. The library does not guard against these cases by inspecting value types at runtime. However, if the source code keeps track of the data type, e.g. join() should never been called with data of the wrong type (e.g. with a just of an array). Thus, such silent errors of join would never occur in practise. The other way around, recursively flattening an Array containing Maybes will destroy all Maybe elements. This can only be prevented by using Array.flat with the accurate deepness.","title":"Maybe"},{"location":"maybe/#maybe","text":"Working with optional data, commonly done with if - else blocks. Native JavaScript arrays which are empty or have a single element are considered a Maybe here.","title":"Maybe"},{"location":"maybe/#generators","text":"","title":"Generators"},{"location":"maybe/#fromnilable-aundefinednull-maybe-a","text":"Generates a maybe from a value which can be nullish. fromNilable({}.foo) // Nothing fromNilable(\"bar\") // Just(\"bar\")","title":"fromNilable :: (a|undefined|null) \u2192 Maybe a"},{"location":"maybe/#fromcontentholdinga","text":":: a \u2192 Maybe a fromContentHolding(\"a\") // Just(\"a\") fromContentHolding(\"\") // Nothing","title":"fromContentHolding(a)"},{"location":"maybe/#frompredicatepredicate-subject","text":":: (a \u2192 Boolean) \u2192 a \u2192 Maybe a If the predicate test holds it returns the subject as a Just , otherwise a Nothing .","title":"fromPredicate(predicate, subject)"},{"location":"maybe/#consumption","text":"","title":"Consumption"},{"location":"maybe/#getorelsedefaultvalue-m","text":":: a -> Maybe a -> a Extract the value of a Just or return the provided default. getOrElse(\"foo\", nothing()); // -> \"foo\" getOrElse(\"foo\", just(\"bar\")); // -> \"bar\"","title":"getOrElse(defaultValue, m)"},{"location":"maybe/#maybeonnothing-dowithjust-m","text":":: (() -> b) -> (a -> b) -> Maybe a -> b Composition of getOrElse and map . Transforms the value if it exists with the provided function. Otherwise, returns the default value.","title":"maybe(onNothing, doWithJust, m)"},{"location":"maybe/#transformation","text":"","title":"Transformation"},{"location":"maybe/#pluckkey","text":":: Maybe m => k -> m {k: v} -> m v :: Maybe m => number -> m [v] -> m v Simply k => map(R.prop(k)) for mapping to a key value.","title":"pluck(key)"},{"location":"maybe/#sequenceof_f-map_f-maybeoff","text":":: Applicative f => ((a \u2192 f a), ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 Maybe (f a) \u2192 f (Maybe a) Swap the sequence of types: Maybe of Functor of Value to Functor of Maybe of Value. Maybe takes the role of a \"Traversable\" t .","title":"sequence(of_f, map_f, MaybeOfF)"},{"location":"maybe/#examples","text":"","title":"Examples"},{"location":"maybe/#change-a-maybe-of-a-promise-into-a-promise-of-a-maybe","text":"const // :: Maybe Promise e a -> Promise e Maybe a maybeOfPromiseToPromiseOfMaybe = sequence(of_p, map_p); maybeOfPromiseToPromiseOfMaybe(just(Promise.resolve(\"foo\"))); // -> Promise Just \"foo\" maybeOfPromiseToPromiseOfMaybe(just(Promise.reject(\"bar\"))); // -> Promise.reject(\"bar\") maybeOfPromiseToPromiseOfMaybe(nothing()); // -> Promise Nothing // getInputValue :: () -> Maybe string // fetchServer :: string -> Promise data // map_mb :: (a -> b) -> Maybe a -> Maybe b // defaultData :: data const // :: a -> Promise a of_p = value => Promise.resolve(value), // :: (a -> b) -> Promise a -> Promise b map_p = curry((fn, aPromise) => aPromise.then(fn)), // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String map_mb(fetchServer), // :: Maybe Promise Data maybeOfPromiseToPromiseOfMaybe, // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data );","title":"Change a Maybe of a Promise into a Promise of a Maybe"},{"location":"maybe/#change-a-maybe-of-a-key-value-pair-into-a-key-value-pair-of-a-maybe","text":"maybeOfFooObjectToObjectFooOfMaybe :: Maybe {foo: a} \u2192 {foo: Maybe a} import {modify, objOf} from 'ramda'; const ofFooObj = x => ({foo: x}), // :: a \u2192 {foo: a} mapFooObj = modify(\"foo\"), // :: (a \u2192 b) \u2192 {foo: a} \u2192 {foo: b} maybeOfFooObjectToObjectFooOfMaybe = // :: Maybe {foo: a} \u2192 {foo: Maybe a} sequence(ofFooObj, mapFooObj), justFooBar = just({foo: \"bar\"}); // :: Just {foo: \"bar\"} maybeOfFooObjectToObjectFooOfMaybe(justFooBar); // {foo: Maybe \"bar\"}","title":"Change a Maybe of a Key-Value Pair into a Key-Value Pair of a Maybe"},{"location":"maybe/#traverseof_f-map_f-effect_to_f-maybe","text":":: (Applicative f, Traversable t) => (c \u2192 f c) \u2192 ((a \u2192 b) \u2192 f a \u2192 f b) \u2192 (a \u2192 f b) \u2192 Maybe a \u2192 f (Maybe b) Applies an \"effect\" effect_to_f to the value inside the Maybe. Then combines that \"effect\" with the Maybe by wrapping the \"effect's\" result in an Applicative of a Maybe. If, for instance the \"effect\" is an asynchronous computation wrapped in a Promise a \u2192 Promise b , it might make more sense to work with a Promise of a Maybe than a Maybe of a Promise. Using traverse essentially combines mapping the effect_to_f over the Maybe and calling sequence(of_f, map_f) in a single step. // see first example for sequence const // :: (a \u2192 Promise b) \u2192 Maybe a \u2192 Promise Maybe b applyToPromiseOfMaybe = traverse(of_p, map_p), // :: a \u2192 Promise b delayEffect = x => new Promise(resolve => setTimeout(resolve, 1000, x)); applyToPromiseOfMaybe(delayEffect, just(\"foo\")); // -> Promise Just \"foo\" applyToPromiseOfMaybe(delayEffect, nothing()); // -> Promise Nothing // :: () -> Promise Data getServerData = pipe( getInputValue, // :: Maybe String applyToPromiseOfMaybe(fetchServer), // :: Promise Maybe Data map_p(getOrElse(defaultData)) // :: Promise Data );","title":"traverse(of_f, map_f, effect_to_f, maybe)"},{"location":"maybe/#relation-with-sequence","text":"sequence(of_f, map_f, t) \u2261 traverse(of, map, identity, t) , and traverse(of_f, map_f, effect_to_f, t) \u2261 sequence(of_f, map_f, map(effect_to_f, t)) . The first two parameters of sequence and traverse are the same and due to the implementation.","title":"Relation with sequence"},{"location":"maybe/#caveats","text":"","title":"Caveats"},{"location":"maybe/#argument-type-checking","text":"This library functions do not guard the user from supplying arguments of a wrong type. In particular, passing some other type as the maybe subject or passing a function to chain which returns a some other type, will cause undefined behaviour later.","title":"Argument type checking"},{"location":"maybe/#value-limitations","text":"Choosing empty and single-element arrays as implementation of the Maybe type causes these ambiguities: - A just and any single element array, - a nothing and any empty array cannot be distinguished. This directly affects the inspection functions isJust , isNothing and equals . E.g. equals(of(x), [x]) is true as well as equals(nothing(), []) is also true . Also join() will treat a just containing an empty array as a just containing nothing which is collapsed to a nothing. The library does not guard against these cases by inspecting value types at runtime. However, if the source code keeps track of the data type, e.g. join() should never been called with data of the wrong type (e.g. with a just of an array). Thus, such silent errors of join would never occur in practise. The other way around, recursively flattening an Array containing Maybes will destroy all Maybe elements. This can only be prevented by using Array.flat with the accurate deepness.","title":"Value limitations"},{"location":"promise/","text":"Promise Represents the eventual outcome or failure of an eagerly executed computation. Related Work and Inspiration Applicative Functors , Futures Generation later(dt, a) :: number \u2192 a \u2192 Promise a of(a) :: a -> Promise e a reject(e) :: * -> Promise * Abbreviates Promise.reject . Note that Promise.reject rejects with any type including any Promise (unsettled, rejected or fulfilled)! Read what happens . never() :: () -> Promise () Creates a Promise which never settles. Transformation chainRej(onError) :: (e -> Promise g b) -> Promise e a -> Promise (e | g) (a | b) coalesce(onFailure, onSuccess, p) :: (e -> b) -> (a -> b) -> Promise e a -> Promise e b It's essentially Promise.then and named coalesce in crocks Async. Side-Effects bi_tap(onFailure, onSuccess, p) :: (* -> *) -> (a -> *) -> Promise a -> Promise a Like tap but also with a failure side-effect function. tap(fn, p) :: (a -> *) -> Promise a -> Promise a In this implementation an exception in the side-effect fn rubs off to the Promise. tapRegardless(fn, p) :: (a -> *) -> Promise a -> Promise a Execute a synchronous side effect. Aka forEach . In this implementation an exception in the side-effect is ignored. promise X ---------> X ---> \\ - fn(X) -> Y chainTap(fn, p) :: (a -> Promise g *) -> Promise e a -> Promise (e|g) a Execute an asynchronous (could be a side-effect) function and wait until it is settled. Mostly like tap except for the wait part. Combination ap(promisedFunc, promise) :: Promise (a \u2192 b) \u2192 Promise a \u2192 Promise b Parallel running version: Both Promises are treated equally in time, meaning if any fails the first failure is propagated to the result. duplexRace(a, b) :: Promise a \u2192 Promise a \u2192 Promise a It's Promise.race but only for two input promises.","title":"Promise"},{"location":"promise/#promise","text":"Represents the eventual outcome or failure of an eagerly executed computation.","title":"Promise"},{"location":"promise/#related-work-and-inspiration","text":"Applicative Functors , Futures","title":"Related Work and Inspiration"},{"location":"promise/#generation","text":"","title":"Generation"},{"location":"promise/#laterdt-a","text":":: number \u2192 a \u2192 Promise a","title":"later(dt, a)"},{"location":"promise/#ofa","text":":: a -> Promise e a","title":"of(a)"},{"location":"promise/#rejecte","text":":: * -> Promise * Abbreviates Promise.reject . Note that Promise.reject rejects with any type including any Promise (unsettled, rejected or fulfilled)! Read what happens .","title":"reject(e)"},{"location":"promise/#never","text":":: () -> Promise () Creates a Promise which never settles.","title":"never()"},{"location":"promise/#transformation","text":"","title":"Transformation"},{"location":"promise/#chainrejonerror","text":":: (e -> Promise g b) -> Promise e a -> Promise (e | g) (a | b)","title":"chainRej(onError)"},{"location":"promise/#coalesceonfailure-onsuccess-p","text":":: (e -> b) -> (a -> b) -> Promise e a -> Promise e b It's essentially Promise.then and named coalesce in crocks Async.","title":"coalesce(onFailure, onSuccess, p)"},{"location":"promise/#side-effects","text":"","title":"Side-Effects"},{"location":"promise/#bi_taponfailure-onsuccess-p","text":":: (* -> *) -> (a -> *) -> Promise a -> Promise a Like tap but also with a failure side-effect function.","title":"bi_tap(onFailure, onSuccess, p)"},{"location":"promise/#tapfn-p","text":":: (a -> *) -> Promise a -> Promise a In this implementation an exception in the side-effect fn rubs off to the Promise.","title":"tap(fn, p)"},{"location":"promise/#tapregardlessfn-p","text":":: (a -> *) -> Promise a -> Promise a Execute a synchronous side effect. Aka forEach . In this implementation an exception in the side-effect is ignored. promise X ---------> X ---> \\ - fn(X) -> Y","title":"tapRegardless(fn, p)"},{"location":"promise/#chaintapfn-p","text":":: (a -> Promise g *) -> Promise e a -> Promise (e|g) a Execute an asynchronous (could be a side-effect) function and wait until it is settled. Mostly like tap except for the wait part.","title":"chainTap(fn, p)"},{"location":"promise/#combination","text":"","title":"Combination"},{"location":"promise/#appromisedfunc-promise","text":":: Promise (a \u2192 b) \u2192 Promise a \u2192 Promise b Parallel running version: Both Promises are treated equally in time, meaning if any fails the first failure is propagated to the result.","title":"ap(promisedFunc, promise)"},{"location":"promise/#duplexracea-b","text":":: Promise a \u2192 Promise a \u2192 Promise a It's Promise.race but only for two input promises.","title":"duplexRace(a, b)"},{"location":"transformations/","text":"Natural Transformations Async Stuff maybeOfCancelableToCancelableOfMaybe(mma) :: Maybe Cancelable e a -> Cancelable e Maybe a eitherToCancelable(either) :: Either e a \u2192 Cancelable e a eitherToPromise :: Either c a \u2192 Promise a Since the Either represents an immediate value, the returned Promise is settled. promiseToCancelable(promise) :: Promise e a \u2192 Cancelable e a The transformation is with limitations: - Eagerness cannot be transformed into laziness, i.e. the computation represented by the promise is already executing or even settled. - The computation cannot be cancelled. Cancelling the resulting Cancelable will simply prevent the continuation callbacks from getting called once the promise settles. See cancelable/cancelify . Note that promiseToCancelable(p) \u2261 cancelify(() => p) . cancelableToPromise(cancelable) :: Cancelable e a \u2192 Promise e a Since promises are eager, this transformation will run the cancelable computation. The ability to cancel the computation will be lost. Note that in principle, the ability to cancel the computation could be maintained. However, a result of the cancellation would then be that the created Promise never settles. That is considered to be bad practise. maybeOfPromiseToPromiseOfMaybe(promiseOfMaybe) :: Maybe Promise e a -> Promise e Maybe a Deprecated: instead use maybe/sequence(of_p, map_p) Async into/from Reactive Streams cancelableToEventStream(cancelable) :: Cancelable e a \u2192 EventStream e a Creates a single-valued Bacon.js EventStream observable. If the stream ends after the Cancelable Computation has settled , the cancel function of the latter is (of course) not called. observableToCancelable(observable) :: Observable e a \u2192 Cancelable e a It evaluates the last event (error or value event) of the given observable. cancelableToMostStream(cancelable) :: Cancelable a \u2192 Stream a Crates a single-valued @most/core Stream . mostStreamToCancelable(stream) :: Stream a \u2192 Cancelable a If not cancelled the resulting Cancelable Computation will continue with the last value, or the first error in the stream. Maybe/Either into/from Reactive Streams maybeOfBaconObservableToBaconObservableOfMaybe(maybeObservable) :: Maybe Observable a -> Observable Maybe a Extracting from/Wrapping with Collections keyMaybeToMaybeObj(key, coll) :: key -> {key: Maybe a, \u2026} -> Maybe {key: a, \u2026} :: Idx -> [Idx: Maybe a, \u2026] -> Maybe [Idx: a, \u2026] Deprecated: Consider from lens sequence(propertyLens(key)(map_mb), coll) or sequence(indexLens(idx)(map_mb), coll) .","title":"Transformations"},{"location":"transformations/#natural-transformations","text":"","title":"Natural Transformations"},{"location":"transformations/#async-stuff","text":"","title":"Async Stuff"},{"location":"transformations/#maybeofcancelabletocancelableofmaybemma","text":":: Maybe Cancelable e a -> Cancelable e Maybe a","title":"maybeOfCancelableToCancelableOfMaybe(mma)"},{"location":"transformations/#eithertocancelableeither","text":":: Either e a \u2192 Cancelable e a","title":"eitherToCancelable(either)"},{"location":"transformations/#eithertopromise","text":":: Either c a \u2192 Promise a Since the Either represents an immediate value, the returned Promise is settled.","title":"eitherToPromise"},{"location":"transformations/#promisetocancelablepromise","text":":: Promise e a \u2192 Cancelable e a The transformation is with limitations: - Eagerness cannot be transformed into laziness, i.e. the computation represented by the promise is already executing or even settled. - The computation cannot be cancelled. Cancelling the resulting Cancelable will simply prevent the continuation callbacks from getting called once the promise settles. See cancelable/cancelify . Note that promiseToCancelable(p) \u2261 cancelify(() => p) .","title":"promiseToCancelable(promise)"},{"location":"transformations/#cancelabletopromisecancelable","text":":: Cancelable e a \u2192 Promise e a Since promises are eager, this transformation will run the cancelable computation. The ability to cancel the computation will be lost. Note that in principle, the ability to cancel the computation could be maintained. However, a result of the cancellation would then be that the created Promise never settles. That is considered to be bad practise.","title":"cancelableToPromise(cancelable)"},{"location":"transformations/#maybeofpromisetopromiseofmaybepromiseofmaybe","text":":: Maybe Promise e a -> Promise e Maybe a Deprecated: instead use maybe/sequence(of_p, map_p)","title":"maybeOfPromiseToPromiseOfMaybe(promiseOfMaybe)"},{"location":"transformations/#async-intofrom-reactive-streams","text":"","title":"Async into/from Reactive Streams"},{"location":"transformations/#cancelabletoeventstreamcancelable","text":":: Cancelable e a \u2192 EventStream e a Creates a single-valued Bacon.js EventStream observable. If the stream ends after the Cancelable Computation has settled , the cancel function of the latter is (of course) not called.","title":"cancelableToEventStream(cancelable)"},{"location":"transformations/#observabletocancelableobservable","text":":: Observable e a \u2192 Cancelable e a It evaluates the last event (error or value event) of the given observable.","title":"observableToCancelable(observable)"},{"location":"transformations/#cancelabletomoststreamcancelable","text":":: Cancelable a \u2192 Stream a Crates a single-valued @most/core Stream .","title":"cancelableToMostStream(cancelable)"},{"location":"transformations/#moststreamtocancelablestream","text":":: Stream a \u2192 Cancelable a If not cancelled the resulting Cancelable Computation will continue with the last value, or the first error in the stream.","title":"mostStreamToCancelable(stream)"},{"location":"transformations/#maybeeither-intofrom-reactive-streams","text":"","title":"Maybe/Either into/from Reactive Streams"},{"location":"transformations/#maybeofbaconobservabletobaconobservableofmaybemaybeobservable","text":":: Maybe Observable a -> Observable Maybe a","title":"maybeOfBaconObservableToBaconObservableOfMaybe(maybeObservable)"},{"location":"transformations/#extracting-fromwrapping-with-collections","text":"","title":"Extracting from/Wrapping with Collections"},{"location":"transformations/#keymaybetomaybeobjkey-coll","text":":: key -> {key: Maybe a, \u2026} -> Maybe {key: a, \u2026} :: Idx -> [Idx: Maybe a, \u2026] -> Maybe [Idx: a, \u2026] Deprecated: Consider from lens sequence(propertyLens(key)(map_mb), coll) or sequence(indexLens(idx)(map_mb), coll) .","title":"keyMaybeToMaybeObj(key, coll)"}]}